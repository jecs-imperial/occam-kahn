'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(sortedVertices) {
    _classCallCheck(this, Graph);

    this.sortedVertices = sortedVertices;
  }

  _createClass(Graph, [{
    key: 'getSortedVertices',
    value: function getSortedVertices() {
      return this.sortedVertices;
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertices = [],
          edges = [];

      verticesAndEdgesFromVertexLiterals(vertexLiterals, vertices, edges);

      var sortedVertices = sortedVerticesFromVerticesAndEdges(vertices, edges),
          graph = new Graph(sortedVertices);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function verticesAndEdgesFromVertexLiterals(vertexLiterals, vertices, edges) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        descendantVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement; ///

    var vertex = void 0;

    var vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (vertexExists) {
      vertex = vertexMap[vertexName];
    } else {
      vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;

      vertices.push(vertex);
    }

    descendantVertexNames.forEach(function (descendantVertexName) {
      var descendantVertex = void 0;

      var descendantVertexExists = vertexMap.hasOwnProperty(descendantVertexName);

      if (descendantVertexExists) {
        descendantVertex = vertexMap[descendantVertexName];
      } else {
        descendantVertex = Vertex.fromVertexName(descendantVertexName);

        vertexMap[descendantVertexName] = descendantVertex;

        vertices.push(descendantVertex);
      }

      var firstVertex = vertex,
          secondVertex = descendantVertex,
          edge = new Edge(firstVertex, secondVertex);

      edges.push(edge);

      var incomingEdge = edge;

      descendantVertex.addIncomingEdge(incomingEdge);
    });
  });
}

function sortedVerticesFromVerticesAndEdges(vertices, edges) {
  var sortedVertices = [];

  var startingVertices = vertices.filter(function (vertex) {
    var vertexStarting = vertex.isStarting();

    return vertexStarting;
  });

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        sortedVertex = startingVertex; ///

    sortedVertices.push(sortedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var firstVertex = edge.getFirstVertex(),
          edgeStarting = firstVertex === startingVertex;

      if (edgeStarting) {
        edges.splice(index, 1);

        var lastVertex = edge.getLastVertex(),
            incomingEdge = edge; ///

        lastVertex.removeIncomingEdge(incomingEdge);

        var lastVertexStarting = lastVertex.isStarting();

        if (lastVertexStarting) {
          startingVertices.push(lastVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength > 0) {
    sortedVertices = null;
  }

  return sortedVertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwic29ydGVkVmVydGljZXMiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRpY2VzIiwiZWRnZXMiLCJ2ZXJ0aWNlc0FuZEVkZ2VzRnJvbVZlcnRleExpdGVyYWxzIiwic29ydGVkVmVydGljZXNGcm9tVmVydGljZXNBbmRFZGdlcyIsImdyYXBoIiwibW9kdWxlIiwiZXhwb3J0cyIsInZlcnRleE1hcCIsImZvckVhY2giLCJ2ZXJ0ZXhMaXRlcmFsIiwiZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCIsImZpcnN0Iiwic2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJzZWNvbmQiLCJkZXNjZW5kYW50VmVydGV4TmFtZXMiLCJ2ZXJ0ZXhOYW1lIiwidmVydGV4IiwidmVydGV4RXhpc3RzIiwiaGFzT3duUHJvcGVydHkiLCJmcm9tVmVydGV4TmFtZSIsInB1c2giLCJkZXNjZW5kYW50VmVydGV4TmFtZSIsImRlc2NlbmRhbnRWZXJ0ZXgiLCJkZXNjZW5kYW50VmVydGV4RXhpc3RzIiwiZmlyc3RWZXJ0ZXgiLCJzZWNvbmRWZXJ0ZXgiLCJlZGdlIiwiaW5jb21pbmdFZGdlIiwiYWRkSW5jb21pbmdFZGdlIiwic3RhcnRpbmdWZXJ0aWNlcyIsImZpbHRlciIsInZlcnRleFN0YXJ0aW5nIiwiaXNTdGFydGluZyIsInN0YXJ0aW5nVmVydGljZXNMZW5ndGgiLCJsZW5ndGgiLCJzdGFydGluZ1ZlcnRleCIsInBvcCIsInNvcnRlZFZlcnRleCIsImJhY2t3YXJkc0ZvckVhY2giLCJpbmRleCIsImdldEZpcnN0VmVydGV4IiwiZWRnZVN0YXJ0aW5nIiwic3BsaWNlIiwibGFzdFZlcnRleCIsImdldExhc3RWZXJ0ZXgiLCJyZW1vdmVJbmNvbWluZ0VkZ2UiLCJsYXN0VmVydGV4U3RhcnRpbmciLCJlZGdlc0xlbmd0aCJdLCJtYXBwaW5ncyI6IkFB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RCxRQUFNQyxpQkFBaUJOLGlCQUFpQk8sR0FBakIsRUFBdkI7QUFBQSxRQUNNQyxlQUFlRixjQURyQixDQVp5RCxDQWFuQjs7QUFFdENyQyxtQkFBZXNCLElBQWYsQ0FBb0JpQixZQUFwQjs7QUFFQXpDLGNBQVUwQyxnQkFBVixDQUEyQnJDLEtBQTNCLEVBQWtDLFVBQVN5QixJQUFULEVBQWVhLEtBQWYsRUFBc0I7QUFDdEQsVUFBTWYsY0FBY0UsS0FBS2MsY0FBTCxFQUFwQjtBQUFBLFVBQ01DLGVBQWdCakIsZ0JBQWdCVyxjQUR0Qzs7QUFHQSxVQUFJTSxZQUFKLEVBQWtCO0FBQ2hCeEMsY0FBTXlDLE1BQU4sQ0FBYUgsS0FBYixFQUFvQixDQUFwQjs7QUFFQSxZQUFNSSxhQUFhakIsS0FBS2tCLGFBQUwsRUFBbkI7QUFBQSxZQUNNakIsZUFBZUQsSUFEckIsQ0FIZ0IsQ0FJWTs7QUFFNUJpQixtQkFBV0Usa0JBQVgsQ0FBOEJsQixZQUE5Qjs7QUFFQSxZQUFNbUIscUJBQXFCSCxXQUFXWCxVQUFYLEVBQTNCOztBQUVBLFlBQUljLGtCQUFKLEVBQXdCO0FBQ3RCakIsMkJBQWlCVCxJQUFqQixDQUFzQnVCLFVBQXRCO0FBQ0Q7QUFDRjtBQUNGLEtBbEJEOztBQW9CQVYsNkJBQXlCSixpQkFBaUJLLE1BQTFDO0FBckN5RDs7QUFXM0QsU0FBT0QseUJBQXlCLENBQWhDLEVBQW1DO0FBQUE7QUEyQmxDOztBQUVELE1BQU1jLGNBQWM5QyxNQUFNaUMsTUFBMUI7O0FBRUEsTUFBSWEsY0FBYyxDQUFsQixFQUFxQjtBQUNuQmpELHFCQUFpQixJQUFqQjtBQUNEOztBQUVELFNBQU9BLGNBQVA7QUFDRCIsImZpbGUiOiJncmFwaC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZ3JhcGgvZWRnZScpLFxuICAgICAgVmVydGV4ID0gcmVxdWlyZSgnLi9ncmFwaC92ZXJ0ZXgnKSxcbiAgICAgIGFycmF5VXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9hcnJheScpO1xuXG5jbGFzcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yIChzb3J0ZWRWZXJ0aWNlcykge1xuICAgIHRoaXMuc29ydGVkVmVydGljZXMgPSBzb3J0ZWRWZXJ0aWNlcztcbiAgfVxuXG4gIGdldFNvcnRlZFZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnNvcnRlZFZlcnRpY2VzO1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscykge1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW10sXG4gICAgICAgICAgZWRnZXMgPSBbXTtcblxuICAgIHZlcnRpY2VzQW5kRWRnZXNGcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMsIHZlcnRpY2VzLCBlZGdlcyk7XG5cbiAgICBjb25zdCBzb3J0ZWRWZXJ0aWNlcyA9IHNvcnRlZFZlcnRpY2VzRnJvbVZlcnRpY2VzQW5kRWRnZXModmVydGljZXMsIGVkZ2VzKSxcbiAgICAgICAgICBncmFwaCA9IG5ldyBHcmFwaChzb3J0ZWRWZXJ0aWNlcyk7XG4gICAgXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG5cbmZ1bmN0aW9uIHZlcnRpY2VzQW5kRWRnZXNGcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMsIHZlcnRpY2VzLCBlZGdlcykge1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcblxuICB2ZXJ0ZXhMaXRlcmFscy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleExpdGVyYWwpIHtcbiAgICBjb25zdCBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLmZpcnN0KHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLnNlY29uZCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBkZXNjZW5kYW50VmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4TmFtZSA9IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQ7IC8vL1xuXG4gICAgbGV0IHZlcnRleDtcblxuICAgIGNvbnN0IHZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhOYW1lKTtcblxuICAgIGlmICh2ZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIHZlcnRleCA9IHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKHZlcnRleE5hbWUpO1xuXG4gICAgICB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0gPSB2ZXJ0ZXg7XG5cbiAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICB9XG5cbiAgICBkZXNjZW5kYW50VmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbihkZXNjZW5kYW50VmVydGV4TmFtZSkge1xuICAgICAgbGV0IGRlc2NlbmRhbnRWZXJ0ZXg7XG5cbiAgICAgIGNvbnN0IGRlc2NlbmRhbnRWZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkoZGVzY2VuZGFudFZlcnRleE5hbWUpO1xuXG4gICAgICBpZiAoZGVzY2VuZGFudFZlcnRleEV4aXN0cykge1xuICAgICAgICBkZXNjZW5kYW50VmVydGV4ID0gdmVydGV4TWFwW2Rlc2NlbmRhbnRWZXJ0ZXhOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc2NlbmRhbnRWZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUoZGVzY2VuZGFudFZlcnRleE5hbWUpO1xuXG4gICAgICAgIHZlcnRleE1hcFtkZXNjZW5kYW50VmVydGV4TmFtZV0gPSBkZXNjZW5kYW50VmVydGV4O1xuXG4gICAgICAgIHZlcnRpY2VzLnB1c2goZGVzY2VuZGFudFZlcnRleCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0VmVydGV4ID0gdmVydGV4LFxuICAgICAgICAgICAgc2Vjb25kVmVydGV4ID0gZGVzY2VuZGFudFZlcnRleCxcbiAgICAgICAgICAgIGVkZ2UgPSBuZXcgRWRnZShmaXJzdFZlcnRleCwgc2Vjb25kVmVydGV4KTtcblxuICAgICAgZWRnZXMucHVzaChlZGdlKTtcblxuICAgICAgY29uc3QgaW5jb21pbmdFZGdlID0gZWRnZTtcblxuICAgICAgZGVzY2VuZGFudFZlcnRleC5hZGRJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZFZlcnRpY2VzRnJvbVZlcnRpY2VzQW5kRWRnZXModmVydGljZXMsIGVkZ2VzKSB7XG4gIGxldCBzb3J0ZWRWZXJ0aWNlcyA9IFtdO1xuICBcbiAgY29uc3Qgc3RhcnRpbmdWZXJ0aWNlcyA9IHZlcnRpY2VzLmZpbHRlcihmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXhTdGFydGluZyA9IHZlcnRleC5pc1N0YXJ0aW5nKCk7XG4gICAgICBcbiAgICAgICAgICByZXR1cm4gdmVydGV4U3RhcnRpbmc7XG4gICAgICAgIH0pO1xuXG4gIGxldCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSBzdGFydGluZ1ZlcnRpY2VzLnBvcCgpLFxuICAgICAgICAgIHNvcnRlZFZlcnRleCA9IHN0YXJ0aW5nVmVydGV4OyAgLy8vXG5cbiAgICBzb3J0ZWRWZXJ0aWNlcy5wdXNoKHNvcnRlZFZlcnRleCk7XG5cbiAgICBhcnJheVV0aWwuYmFja3dhcmRzRm9yRWFjaChlZGdlcywgZnVuY3Rpb24oZWRnZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IGZpcnN0VmVydGV4ID0gZWRnZS5nZXRGaXJzdFZlcnRleCgpLFxuICAgICAgICAgICAgZWRnZVN0YXJ0aW5nID0gKGZpcnN0VmVydGV4ID09PSBzdGFydGluZ1ZlcnRleCk7XG5cbiAgICAgIGlmIChlZGdlU3RhcnRpbmcpIHtcbiAgICAgICAgZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICBjb25zdCBsYXN0VmVydGV4ID0gZWRnZS5nZXRMYXN0VmVydGV4KCksXG4gICAgICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgICAgICBsYXN0VmVydGV4LnJlbW92ZUluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuXG4gICAgICAgIGNvbnN0IGxhc3RWZXJ0ZXhTdGFydGluZyA9IGxhc3RWZXJ0ZXguaXNTdGFydGluZygpO1xuXG4gICAgICAgIGlmIChsYXN0VmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICBzdGFydGluZ1ZlcnRpY2VzLnB1c2gobGFzdFZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPSBzdGFydGluZ1ZlcnRpY2VzLmxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IGVkZ2VzTGVuZ3RoID0gZWRnZXMubGVuZ3RoO1xuXG4gIGlmIChlZGdlc0xlbmd0aCA+IDApIHtcbiAgICBzb3J0ZWRWZXJ0aWNlcyA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gc29ydGVkVmVydGljZXM7XG59XG4iXX0=