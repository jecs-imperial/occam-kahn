'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(sortedVertices) {
    _classCallCheck(this, Graph);

    this.sortedVertices = sortedVertices;
  }

  _createClass(Graph, [{
    key: 'getSortedVertices',
    value: function getSortedVertices() {
      return this.sortedVertices;
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertices = [],
          edges = [];

      verticesAndEdgesFromVertexLiterals(vertexLiterals, vertices, edges);

      var sortedVertices = sortedVerticesFromVerticesAndEdges(vertices, edges);

      addAncestorVerticesToSortedVertices(sortedVertices);

      var graph = new Graph(sortedVertices);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function verticesAndEdgesFromVertexLiterals(vertexLiterals, vertices, edges) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement; ///

    var vertex = void 0;

    var vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (vertexExists) {
      vertex = vertexMap[vertexName];
    } else {
      vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;

      vertices.push(vertex);
    }

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertex = void 0;

      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (ancestorVertexExists) {
        ancestorVertex = vertexMap[ancestorVertexName];
      } else {
        ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;

        vertices.push(ancestorVertex);
      }

      var firstVertex = vertex,
          secondVertex = ancestorVertex,
          edge = new Edge(firstVertex, secondVertex);

      edges.push(edge);

      var incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      vertex.addIncomingEdge(incomingEdge);

      ancestorVertex.addOutgoingEdge(outgoingEdge);
    });
  });
}

function sortedVerticesFromVerticesAndEdges(vertices, edges) {
  var sortedVertices = [];

  var startingVertices = vertices.filter(function (vertex) {
    var vertexStarting = vertex.isStarting();

    return vertexStarting;
  });

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        sortedVertex = startingVertex; ///

    sortedVertices.push(sortedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var firstVertex = edge.getFirstVertex(),
          edgeStarting = firstVertex === startingVertex;

      if (edgeStarting) {
        edges.splice(index, 1);

        var lastVertex = edge.getLastVertex(),
            incomingEdge = edge; ///

        lastVertex.removeIncomingEdge(incomingEdge);

        var lastVertexStarting = lastVertex.isStarting();

        if (lastVertexStarting) {
          startingVertices.push(lastVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength > 0) {
    sortedVertices = null;
  }

  return sortedVertices;
}

function addAncestorVerticesToSortedVertices(sortedVertices) {
  if (sortedVertices !== null) {
    sortedVertices.forEach(function (sortedVertex) {
      sortedVertex.forEachOutgoingEdge(function (outgoingEdge) {
        var outgoingEdgeLastVertex = outgoingEdge.getLastVertex(),
            descendantVertex = outgoingEdgeLastVertex,
            ///
        ancestorVertex = sortedVertex,
            ///
        ancestorVertices = ancestorVertex.getAncestorVertices(); ///

        descendantVertex.addAncestorVertices(ancestorVertices);

        descendantVertex.addAncestorVertex(ancestorVertex);
      });
    });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwic29ydGVkVmVydGljZXMiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRpY2VzIiwiZWRnZXMiLCJ2ZXJ0aWNlc0FuZEVkZ2VzRnJvbVZlcnRleExpdGVyYWxzIiwic29ydGVkVmVydGljZXNGcm9tVmVydGljZXNBbmRFZGdlcyIsImFkZEFuY2VzdG9yVmVydGljZXNUb1NvcnRlZFZlcnRpY2VzIiwiZ3JhcGgiLCJtb2R1bGUiLCJleHBvcnRzIiwidmVydGV4TWFwIiwiZm9yRWFjaCIsInZlcnRleExpdGVyYWwiLCJmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50IiwiZmlyc3QiLCJzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCIsInNlY29uZCIsImFuY2VzdG9yVmVydGV4TmFtZXMiLCJ2ZXJ0ZXhOYW1lIiwidmVydGV4IiwidmVydGV4RXhpc3RzIiwiaGFzT3duUHJvcGVydHkiLCJmcm9tVmVydGV4TmFtZSIsInB1c2giLCJhbmNlc3RvclZlcnRleE5hbWUiLCJhbmNlc3RvclZlcnRleCIsImFuY2VzdG9yVmVydGV4RXhpc3RzIiwiZmlyc3RWZXJ0ZXgiLCJzZWNvbmRWZXJ0ZXgiLCJlZGdlIiwiaW5jb21pbmdFZGdlIiwib3V0Z29pbmdFZGdlIiwiYWRkSW5jb21pbmdFZGdlIiwiYWRkT3V0Z29pbmdFZGdlIiwic3RhcnRpbmdWZXJ0aWNlcyIsImZpbHRlciIsInZlcnRleFN0YXJ0aW5nIiwiaXNTdGFydGluZyIsInN0YXJ0aW5nVmVydGljZXNMZW5ndGgiLCJsZW5ndGgiLCJzdGFydGluZ1ZlcnRleCIsInBvcCIsInNvcnRlZFZlcnRleCIsImJhY2t3YXJkc0ZvckVhY2giLCJpbmRleCIsImdldEZpcnN0VmVydGV4IiwiZWRnZVN0YXJ0aW5nIiwic3BsaWNlIiwibGFzdFZlcnRleCIsImdldExhc3RWZXJ0ZXgiLCJyZW1vdmVJbmNvbWluZ0VkZ2UiLCJsYXN0VmVydGV4U3RhcnRpbmciLCJlZGdlc0xlbmd0aCIsImZvckVhY2hPdXRnb2luZ0VkZ2UiLCJvdXRnb2luZ0VkZ2VMYXN0VmVydGV4IiwiZGVzY2VuZGFudFZlcnRleCIsImFuY2VzdG9yVmVydGljZXMiLCJnZXRBbmNlc3RvclZlcnRpY2VzIiwiYWRkQW5jZXN0b3JWZXJ0aWNlcyIsImFkZEFuY2VzdG9yVmVydGV4Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsT0FBT0MsUUFBUSxjQUFSLENBQWI7QUFBQSxJQUNNQyxTQUFTRCxRQUFRLGdCQUFSLENBRGY7QUFBQSxJQUVNRSxZQUFZRixRQUFRLGNBQVIsQ0FGbEI7O0lBSU1HLEs7QUFDSixpQkFBYUMsY0FBYixFQUE2QjtBQUFBOztBQUMzQixTQUFLQSxjQUFMLEdBQXNCQSxjQUF0QjtBQUNEOzs7O3dDQUVtQjtBQUNsQixhQUFPLEtBQUtBLGNBQVo7QUFDRDs7O3VDQUV5QkMsYyxFQUFnQjtBQUN4QyxVQUFNQyxXQUFXLEVBQWpCO0FBQUEsVUFDTUMsUUFBUSxFQURkOztBQUdBQyx5Q0FBbUNILGNBQW5DLEVBQW1EQyxRQUFuRCxFQUE2REMsS0FBN0Q7O0FBRUEsVUFBTUgsaUJBQWlCSyxtQ0FBbUNILFFBQW5DLEVBQTZDQyxLQUE3QyxDQUF2Qjs7QUFFQUcsMENBQW9DTixjQUFwQzs7QUFFQSxVQUFNTyxRQUFRLElBQUlSLEtBQUosQ0FBVUMsY0FBVixDQUFkOztBQUVBLGFBQU9PLEtBQVA7QUFDRDs7Ozs7O0FBR0hDLE9BQU9DLE9BQVAsR0FBaUJWLEtBQWpCOztBQUVBLFNBQVNLLGtDQUFULENBQTRDSCxjQUE1QyxFQUE0REMsUUFBNUQsRUFBc0VDLEtBQXRFLEVBQTZFO0FBQzNFLE1BQU1PLFlBQVksRUFBbEI7O0FBRUFULGlCQUFlVSxPQUFmLENBQXVCLFVBQVNDLGFBQVQsRUFBd0I7QUFDN0MsUUFBTUMsNEJBQTRCZixVQUFVZ0IsS0FBVixDQUFnQkYsYUFBaEIsQ0FBbEM7QUFBQSxRQUNN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eUJBQXlCLENBQWhDLEVBQW1DO0FBQUE7QUEyQmxDOztBQUVELE1BQU1jLGNBQWNqRCxNQUFNb0MsTUFBMUI7O0FBRUEsTUFBSWEsY0FBYyxDQUFsQixFQUFxQjtBQUNuQnBELHFCQUFpQixJQUFqQjtBQUNEOztBQUVELFNBQU9BLGNBQVA7QUFDRDs7QUFFRCxTQUFTTSxtQ0FBVCxDQUE2Q04sY0FBN0MsRUFBNkQ7QUFDM0QsTUFBSUEsbUJBQW1CLElBQXZCLEVBQTZCO0FBQzNCQSxtQkFBZVcsT0FBZixDQUF1QixVQUFTK0IsWUFBVCxFQUF1QjtBQUM1Q0EsbUJBQWFXLG1CQUFiLENBQWlDLFVBQVN0QixZQUFULEVBQXVCO0FBQ3RELFlBQU11Qix5QkFBeUJ2QixhQUFha0IsYUFBYixFQUEvQjtBQUFBLFlBQ01NLG1CQUFtQkQsc0JBRHpCO0FBQUEsWUFDa0Q7QUFDNUM3Qix5QkFBaUJpQixZQUZ2QjtBQUFBLFlBRXNDO0FBQ2hDYywyQkFBbUIvQixlQUFlZ0MsbUJBQWYsRUFIekIsQ0FEc0QsQ0FJVTs7QUFFaEVGLHlCQUFpQkcsbUJBQWpCLENBQXFDRixnQkFBckM7O0FBRUFELHlCQUFpQkksaUJBQWpCLENBQW1DbEMsY0FBbkM7QUFDRCxPQVREO0FBVUQsS0FYRDtBQVlEO0FBQ0YiLCJmaWxlIjoiZ3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVkZ2UgPSByZXF1aXJlKCcuL2dyYXBoL2VkZ2UnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vZ3JhcGgvdmVydGV4JyksXG4gICAgICBhcnJheVV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYXJyYXknKTtcblxuY2xhc3MgR3JhcGgge1xuICBjb25zdHJ1Y3RvciAoc29ydGVkVmVydGljZXMpIHtcbiAgICB0aGlzLnNvcnRlZFZlcnRpY2VzID0gc29ydGVkVmVydGljZXM7XG4gIH1cblxuICBnZXRTb3J0ZWRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0ZWRWZXJ0aWNlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICAgIGVkZ2VzID0gW107XG5cbiAgICB2ZXJ0aWNlc0FuZEVkZ2VzRnJvbVZlcnRleExpdGVyYWxzKHZlcnRleExpdGVyYWxzLCB2ZXJ0aWNlcywgZWRnZXMpO1xuXG4gICAgY29uc3Qgc29ydGVkVmVydGljZXMgPSBzb3J0ZWRWZXJ0aWNlc0Zyb21WZXJ0aWNlc0FuZEVkZ2VzKHZlcnRpY2VzLCBlZGdlcyk7XG4gICAgXG4gICAgYWRkQW5jZXN0b3JWZXJ0aWNlc1RvU29ydGVkVmVydGljZXMoc29ydGVkVmVydGljZXMpO1xuICAgIFxuICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKHNvcnRlZFZlcnRpY2VzKTtcbiAgICBcbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxuZnVuY3Rpb24gdmVydGljZXNBbmRFZGdlc0Zyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscywgdmVydGljZXMsIGVkZ2VzKSB7XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGFuY2VzdG9yVmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4TmFtZSA9IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQ7IC8vL1xuXG4gICAgbGV0IHZlcnRleDtcblxuICAgIGNvbnN0IHZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhOYW1lKTtcblxuICAgIGlmICh2ZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIHZlcnRleCA9IHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKHZlcnRleE5hbWUpO1xuXG4gICAgICB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0gPSB2ZXJ0ZXg7XG5cbiAgICAgIHZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICB9XG5cbiAgICBhbmNlc3RvclZlcnRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24oYW5jZXN0b3JWZXJ0ZXhOYW1lKSB7XG4gICAgICBsZXQgYW5jZXN0b3JWZXJ0ZXg7XG5cbiAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KGFuY2VzdG9yVmVydGV4TmFtZSk7XG5cbiAgICAgIGlmIChhbmNlc3RvclZlcnRleEV4aXN0cykge1xuICAgICAgICBhbmNlc3RvclZlcnRleCA9IHZlcnRleE1hcFthbmNlc3RvclZlcnRleE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jZXN0b3JWZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUoYW5jZXN0b3JWZXJ0ZXhOYW1lKTtcblxuICAgICAgICB2ZXJ0ZXhNYXBbYW5jZXN0b3JWZXJ0ZXhOYW1lXSA9IGFuY2VzdG9yVmVydGV4O1xuXG4gICAgICAgIHZlcnRpY2VzLnB1c2goYW5jZXN0b3JWZXJ0ZXgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaXJzdFZlcnRleCA9IHZlcnRleCxcbiAgICAgICAgICAgIHNlY29uZFZlcnRleCA9IGFuY2VzdG9yVmVydGV4LFxuICAgICAgICAgICAgZWRnZSA9IG5ldyBFZGdlKGZpcnN0VmVydGV4LCBzZWNvbmRWZXJ0ZXgpO1xuXG4gICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICBjb25zdCBpbmNvbWluZ0VkZ2UgPSBlZGdlLCAgLy8vXG4gICAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgIHZlcnRleC5hZGRJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcblxuICAgICAgYW5jZXN0b3JWZXJ0ZXguYWRkT3V0Z29pbmdFZGdlKG91dGdvaW5nRWRnZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzb3J0ZWRWZXJ0aWNlc0Zyb21WZXJ0aWNlc0FuZEVkZ2VzKHZlcnRpY2VzLCBlZGdlcykge1xuICBsZXQgc29ydGVkVmVydGljZXMgPSBbXTtcbiAgXG4gIGNvbnN0IHN0YXJ0aW5nVmVydGljZXMgPSB2ZXJ0aWNlcy5maWx0ZXIoZnVuY3Rpb24odmVydGV4KSB7XG4gICAgICAgICAgY29uc3QgdmVydGV4U3RhcnRpbmcgPSB2ZXJ0ZXguaXNTdGFydGluZygpO1xuICAgICAgXG4gICAgICAgICAgcmV0dXJuIHZlcnRleFN0YXJ0aW5nO1xuICAgICAgICB9KTtcblxuICBsZXQgc3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCA9IHN0YXJ0aW5nVmVydGljZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4ID0gc3RhcnRpbmdWZXJ0aWNlcy5wb3AoKSxcbiAgICAgICAgICBzb3J0ZWRWZXJ0ZXggPSBzdGFydGluZ1ZlcnRleDsgIC8vL1xuXG4gICAgc29ydGVkVmVydGljZXMucHVzaChzb3J0ZWRWZXJ0ZXgpO1xuXG4gICAgYXJyYXlVdGlsLmJhY2t3YXJkc0ZvckVhY2goZWRnZXMsIGZ1bmN0aW9uKGVkZ2UsIGluZGV4KSB7XG4gICAgICBjb25zdCBmaXJzdFZlcnRleCA9IGVkZ2UuZ2V0Rmlyc3RWZXJ0ZXgoKSxcbiAgICAgICAgICAgIGVkZ2VTdGFydGluZyA9IChmaXJzdFZlcnRleCA9PT0gc3RhcnRpbmdWZXJ0ZXgpO1xuXG4gICAgICBpZiAoZWRnZVN0YXJ0aW5nKSB7XG4gICAgICAgIGVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgY29uc3QgbGFzdFZlcnRleCA9IGVkZ2UuZ2V0TGFzdFZlcnRleCgpLFxuICAgICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgICAgbGFzdFZlcnRleC5yZW1vdmVJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcblxuICAgICAgICBjb25zdCBsYXN0VmVydGV4U3RhcnRpbmcgPSBsYXN0VmVydGV4LmlzU3RhcnRpbmcoKTtcblxuICAgICAgICBpZiAobGFzdFZlcnRleFN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRpbmdWZXJ0aWNlcy5wdXNoKGxhc3RWZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG4gIH1cblxuICBjb25zdCBlZGdlc0xlbmd0aCA9IGVkZ2VzLmxlbmd0aDtcblxuICBpZiAoZWRnZXNMZW5ndGggPiAwKSB7XG4gICAgc29ydGVkVmVydGljZXMgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRlZFZlcnRpY2VzO1xufVxuXG5mdW5jdGlvbiBhZGRBbmNlc3RvclZlcnRpY2VzVG9Tb3J0ZWRWZXJ0aWNlcyhzb3J0ZWRWZXJ0aWNlcykge1xuICBpZiAoc29ydGVkVmVydGljZXMgIT09IG51bGwpIHtcbiAgICBzb3J0ZWRWZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvcnRlZFZlcnRleCkge1xuICAgICAgc29ydGVkVmVydGV4LmZvckVhY2hPdXRnb2luZ0VkZ2UoZnVuY3Rpb24ob3V0Z29pbmdFZGdlKSB7XG4gICAgICAgIGNvbnN0IG91dGdvaW5nRWRnZUxhc3RWZXJ0ZXggPSBvdXRnb2luZ0VkZ2UuZ2V0TGFzdFZlcnRleCgpLFxuICAgICAgICAgICAgICBkZXNjZW5kYW50VmVydGV4ID0gb3V0Z29pbmdFZGdlTGFzdFZlcnRleCwgIC8vL1xuICAgICAgICAgICAgICBhbmNlc3RvclZlcnRleCA9IHNvcnRlZFZlcnRleCwgIC8vL1xuICAgICAgICAgICAgICBhbmNlc3RvclZlcnRpY2VzID0gYW5jZXN0b3JWZXJ0ZXguZ2V0QW5jZXN0b3JWZXJ0aWNlcygpOyAgLy8vXG5cbiAgICAgICAgZGVzY2VuZGFudFZlcnRleC5hZGRBbmNlc3RvclZlcnRpY2VzKGFuY2VzdG9yVmVydGljZXMpO1xuXG4gICAgICAgIGRlc2NlbmRhbnRWZXJ0ZXguYWRkQW5jZXN0b3JWZXJ0ZXgoYW5jZXN0b3JWZXJ0ZXgpO1xuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufVxuIl19