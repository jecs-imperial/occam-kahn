'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var necessary = require('necessary');

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    RemainingEdges = require('./graph/remainingEdges');

var arrayUtilities = necessary.arrayUtilities,
    first = arrayUtilities.first,
    second = arrayUtilities.second,
    backwardsForEach = arrayUtilities.backwardsForEach;

var Graph = function () {
  function Graph(topologicallyOrderedVertices, remainingEdges) {
    _classCallCheck(this, Graph);

    this.topologicallyOrderedVertices = topologicallyOrderedVertices;
    this.remainingEdges = remainingEdges;
  }

  _createClass(Graph, [{
    key: 'getTopologicallyOrderedVertices',
    value: function getTopologicallyOrderedVertices() {
      return this.topologicallyOrderedVertices;
    }
  }, {
    key: 'getRemainingEdges',
    value: function getRemainingEdges() {
      return this.remainingEdges;
    }
  }, {
    key: 'areCyclesPresent',
    value: function areCyclesPresent() {
      return this.remainingEdges.areCyclesPresent();
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertexMap = vertexMapFromVertexLiterals(vertexLiterals),
          edges = edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap),
          topologicallyOrderedVertices = topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = new RemainingEdges(edges),
          graph = new Graph(topologicallyOrderedVertices, remainingEdges);

      return graph;
    }
  }, {
    key: 'fromVertexNamesAndEdges',
    value: function fromVertexNamesAndEdges(vertexNames, edges) {
      var vertexMap = vertexMapFromVertexNamesAndEdges(vertexNames, edges),
          topologicallyOrderedVertices = topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = new RemainingEdges(edges),
          graph = new Graph(topologicallyOrderedVertices, remainingEdges);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function vertexMapFromVertexNamesAndEdges(vertexNames, edges) {
  var vertexMap = {};

  vertexNames.forEach(function (vertexName) {
    var vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }
  });

  edges.forEach(function (edge) {
    var sourceVertexName = edge.getSourceVertexName(),
        targetVertexName = edge.getTargetVertexName(),
        sourceVertexExists = vertexMap.hasOwnProperty(sourceVertexName),
        targetVertexExists = vertexMap.hasOwnProperty(targetVertexName);

    if (!sourceVertexExists) {
      var _sourceVertex = Vertex.fromVertexName(sourceVertexName);

      vertexMap[sourceVertexName] = _sourceVertex;
    }

    if (!targetVertexExists) {
      var _targetVertex = Vertex.fromVertexName(targetVertexName);

      vertexMap[targetVertexName] = _targetVertex;
    }

    var sourceVertex = vertexMap[sourceVertexName],
        targetVertex = vertexMap[targetVertexName],
        incomingEdge = edge,
        ///
    outgoingEdge = edge; ///

    sourceVertex.addOutgoingEdge(outgoingEdge);

    targetVertex.addIncomingEdge(incomingEdge);
  });

  return vertexMap;
}

function vertexMapFromVertexLiterals(vertexLiterals) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = first(vertexLiteral),
        vertexName = firstVertexLiteralElement,
        ///
    vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }

    var secondVertexLiteralElement = second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (!ancestorVertexExists) {
        var ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;
      }
    });
  });

  return vertexMap;
}

function edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap) {
  var edges = [];

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = first(vertexLiteral),
        secondVertexLiteralElement = second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var sourceVertexName = ancestorVertexName,
          ///
      targetVertexName = vertexName,
          ///
      sourceVertex = vertexMap[sourceVertexName],
          targetVertex = vertexMap[targetVertexName],
          edge = new Edge(sourceVertexName, targetVertexName),
          incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      edges.push(edge);

      sourceVertex.addOutgoingEdge(outgoingEdge);

      targetVertex.addIncomingEdge(incomingEdge);
    });
  });

  return edges;
}

function topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges) {
  var topologicallyOrderedVertexNames = [],
      startingVertexNames = startingVertexNamesFromVertexMap(vertexMap),
      removedEdges = [];

  var startingVertexNamesLength = startingVertexNames.length;

  var _loop = function _loop() {
    var startingVertexName = startingVertexNames.pop(),
        topologicallyOrderedVertexName = startingVertexName; ///

    topologicallyOrderedVertexNames.push(topologicallyOrderedVertexName);

    backwardsForEach(edges, function (edge, index) {
      var sourceVertexName = edge.getSourceVertexName(),
          edgeStarting = sourceVertexName === startingVertexName; ///

      if (edgeStarting) {
        edges.splice(index, 1);

        var targetVertexName = edge.getTargetVertexName(),
            targetVertex = vertexMap[targetVertexName],
            incomingEdge = edge,
            ///
        removedEdge = edge; ///

        targetVertex.removeIncomingEdge(incomingEdge);

        removedEdges.push(removedEdge);

        var targetVertexStarting = targetVertex.isStarting();

        if (targetVertexStarting) {
          var _startingVertexName = targetVertexName; ///

          startingVertexNames.push(_startingVertexName);
        }
      }
    });

    startingVertexNamesLength = startingVertexNames.length;
  };

  while (startingVertexNamesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength === 0) {
    removedEdges.forEach(function (removedEdge) {
      var targetVertexName = removedEdge.getTargetVertexName(),
          targetVertex = vertexMap[targetVertexName],
          incomingEdge = removedEdge; ///

      targetVertex.addIncomingEdge(incomingEdge);
    });
  }

  var topologicallySortedVertices = topologicallyOrderedVertexNames.map(function (topologicallyOrderedVertexName) {
    var topologicallyOrderedVertex = vertexMap[topologicallyOrderedVertexName];

    return topologicallyOrderedVertex;
  });

  return topologicallySortedVertices;
}

function startingVertexNamesFromVertexMap(vertexMap) {
  var vertexNames = Object.keys(vertexMap),
      startingVertexNames = vertexNames.reduce(function (startingVertexNames, vertexName) {
    var vertex = vertexMap[vertexName],
        vertexStarting = vertex.isStarting();

    if (vertexStarting) {
      var _startingVertexName2 = vertexName; ///

      startingVertexNames.push(_startingVertexName2);
    }

    return startingVertexNames;
  }, []);

  return startingVertexNames;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJuZWNlc3NhcnkiLCJyZXF1aXJlIiwiRWRnZSIsIlZlcnRleCIsIlJlbWFpbmluZ0VkZ2VzIiwiYXJyYXlVdGlsaXRpZXMiLCJmaXJzdCIsInNlY29uZCIsImJhY2t3YXJkc0ZvckVhY2giLCJHcmFwaCIsInRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMiLCJyZW1haW5pbmdFZGdlcyIsImFyZUN5Y2xlc1ByZXNlbnQiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRleE1hcCIsInZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyIsImVkZ2VzIiwiZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzRnJvbVZlcnRleE1hcEFuZEVkZ2VzIiwiZ3JhcGgiLCJ2ZXJ0ZXhOYW1lcyIsInZlcnRleE1hcEZyb21WZXJ0ZXhOYW1lc0FuZEVkZ2VzIiwibW9kdWxlIiwiZXhwb3J0cyIsImZvckVhY2giLCJ2ZXJ0ZXhOYW1lIiwidmVydGV4RXhpc3RzIiwiaGFzT3duUHJvcGVydHkiLCJ2ZXJ0ZXgiLCJmcm9tVmVydGV4TmFtZSIsImVkZ2UiLCJzb3VyY2VWZXJ0ZXhOYW1lIiwiZ2V0U291cmNlVmVydGV4TmFtZSIsInRhcmdldFZlcnRleE5hbWUiLCJnZXRUYXJnZXRWZXJ0ZXhOYW1lIiwic291cmNlVmVydGV4RXhpc3RzIiwidGFyZ2V0VmVydGV4RXhpc3RzIiwic291cmNlVmVydGV4IiwidGFyZ2V0VmVydGV4IiwiaW5jb21pbmdFZGdlIiwib3V0Z29pbmdFZGdlIiwiYWRkT3V0Z29pbmdFZGdlIiwiYWRkSW5jb21pbmdFZGdlIiwidmVydGV4TGl0ZXJhbCIsImZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCIsImFuY2VzdG9yVmVydGV4TmFtZXMiLCJhbmNlc3RvclZlcnRleE5hbWUiLCJhbmNlc3RvclZlcnRleEV4aXN0cyIsImFuY2VzdG9yVmVydGV4IiwicHVzaCIsInRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4TmFtZXMiLCJzdGFydGluZ1ZlcnRleE5hbWVzIiwic3RhcnRpbmdWZXJ0ZXhOYW1lc0Zyb21WZXJ0ZXhNYXAiLCJyZW1vdmVkRWRnZXMiLCJzdGFydGluZ1ZlcnRleE5hbWVzTGVuZ3RoIiwibGVuZ3RoIiwic3RhcnRpbmdWZXJ0ZXhOYW1lIiwicG9wIiwidG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXhOYW1lIiwiaW5kZXgiLCJlZGdlU3RhcnRpbmciLCJzcGxpY2UiLCJyZW1vdmVkRWRnZSIsInJlbW92ZUluY29taW5nRWRnZSIsInRhcmdldFZlcnRleFN0YXJ0aW5nIiwiaXNTdGFydGluZyIsImVkZ2VzTGVuZ3RoIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzIiwibWFwIiwidG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXgiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwidmVydGV4U3RhcnRpbmciXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxZQUFZQyxRQUFRLFdBQVIsQ0FBbEI7O0FBRUEsSUFBTUMsT0FBT0QsUUFBUSxjQUFSLENBQWI7QUFBQSxJQUNNRSxTQUFTRixRQUFRLGdCQUFSLENBRGY7QUFBQSxJQUVNRyxpQkFBaUJILFFBQVEsd0JBQVIsQ0FGdkI7O0FBSU0sSUFBRUksY0FBRixHQUFxQkwsU0FBckIsQ0FBRUssY0FBRjtBQUFBLElBQ0VDLEtBREYsR0FDc0NELGNBRHRDLENBQ0VDLEtBREY7QUFBQSxJQUNTQyxNQURULEdBQ3NDRixjQUR0QyxDQUNTRSxNQURUO0FBQUEsSUFDaUJDLGdCQURqQixHQUNzQ0gsY0FEdEMsQ0FDaUJHLGdCQURqQjs7SUFHQUMsSztBQUNKLGlCQUFhQyw0QkFBYixFQUEyQ0MsY0FBM0MsRUFBMkQ7QUFBQTs7QUFDekQsU0FBS0QsNEJBQUwsR0FBb0NBLDRCQUFwQztBQUNBLFNBQUtDLGNBQUwsR0FBc0JBLGNB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Z0NBQVQsQ0FBMEN2QyxTQUExQyxFQUFxRDtBQUNuRCxNQUFNTSxjQUFjbUQsT0FBT0MsSUFBUCxDQUFZMUQsU0FBWixDQUFwQjtBQUFBLE1BQ01zQyxzQkFBc0JoQyxZQUFZcUQsTUFBWixDQUFtQixVQUFTckIsbUJBQVQsRUFBOEIzQixVQUE5QixFQUEwQztBQUNqRixRQUFNRyxTQUFTZCxVQUFVVyxVQUFWLENBQWY7QUFBQSxRQUNNaUQsaUJBQWlCOUMsT0FBT3NDLFVBQVAsRUFEdkI7O0FBR0EsUUFBSVEsY0FBSixFQUFvQjtBQUNsQixVQUFNakIsdUJBQXFCaEMsVUFBM0IsQ0FEa0IsQ0FDc0I7O0FBRXhDMkIsMEJBQW9CRixJQUFwQixDQUF5Qk8sb0JBQXpCO0FBQ0Q7O0FBRUQsV0FBT0wsbUJBQVA7QUFDRCxHQVhxQixFQVduQixFQVhtQixDQUQ1Qjs7QUFjQSxTQUFPQSxtQkFBUDtBQUNEIiwiZmlsZSI6ImdyYXBoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuZWNlc3NhcnkgPSByZXF1aXJlKCduZWNlc3NhcnknKTtcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZ3JhcGgvZWRnZScpLFxuICAgICAgVmVydGV4ID0gcmVxdWlyZSgnLi9ncmFwaC92ZXJ0ZXgnKSxcbiAgICAgIFJlbWFpbmluZ0VkZ2VzID0gcmVxdWlyZSgnLi9ncmFwaC9yZW1haW5pbmdFZGdlcycpO1xuXG5jb25zdCB7IGFycmF5VXRpbGl0aWVzIH0gPSBuZWNlc3NhcnksXG4gICAgICB7IGZpcnN0LCBzZWNvbmQsIGJhY2t3YXJkc0ZvckVhY2ggfSA9IGFycmF5VXRpbGl0aWVzO1xuXG5jbGFzcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yICh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLCByZW1haW5pbmdFZGdlcykge1xuICAgIHRoaXMudG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXM7XG4gICAgdGhpcy5yZW1haW5pbmdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzO1xuICB9XG5cbiAgZ2V0VG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzO1xuICB9XG5cbiAgZ2V0UmVtYWluaW5nRWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtYWluaW5nRWRnZXM7XG4gIH1cblxuICBhcmVDeWNsZXNQcmVzZW50KCkgeyByZXR1cm4gdGhpcy5yZW1haW5pbmdFZGdlcy5hcmVDeWNsZXNQcmVzZW50KCk7IH1cblxuICBzdGF0aWMgZnJvbVZlcnRleExpdGVyYWxzKHZlcnRleExpdGVyYWxzKSB7XG4gICAgY29uc3QgdmVydGV4TWFwID0gdmVydGV4TWFwRnJvbVZlcnRleExpdGVyYWxzKHZlcnRleExpdGVyYWxzKSxcbiAgICAgICAgICBlZGdlcyA9IGVkZ2VzRnJvbVZlcnRleExpdGVyYWxzQW5kVmVydGV4TWFwKHZlcnRleExpdGVyYWxzLCB2ZXJ0ZXhNYXApLFxuICAgICAgICAgIHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMgPSB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzRnJvbVZlcnRleE1hcEFuZEVkZ2VzKHZlcnRleE1hcCwgZWRnZXMpLFxuICAgICAgICAgIHJlbWFpbmluZ0VkZ2VzID0gbmV3IFJlbWFpbmluZ0VkZ2VzKGVkZ2VzKSxcbiAgICAgICAgICBncmFwaCA9IG5ldyBHcmFwaCh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLCByZW1haW5pbmdFZGdlcyk7XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICBzdGF0aWMgZnJvbVZlcnRleE5hbWVzQW5kRWRnZXModmVydGV4TmFtZXMsIGVkZ2VzKSB7XG4gICAgY29uc3QgdmVydGV4TWFwID0gdmVydGV4TWFwRnJvbVZlcnRleE5hbWVzQW5kRWRnZXModmVydGV4TmFtZXMsIGVkZ2VzKSxcbiAgICAgICAgICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzID0gdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlc0Zyb21WZXJ0ZXhNYXBBbmRFZGdlcyh2ZXJ0ZXhNYXAsIGVkZ2VzKSxcbiAgICAgICAgICByZW1haW5pbmdFZGdlcyA9IG5ldyBSZW1haW5pbmdFZGdlcyhlZGdlcyksXG4gICAgICAgICAgZ3JhcGggPSBuZXcgR3JhcGgodG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcywgcmVtYWluaW5nRWRnZXMpO1xuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG5cbmZ1bmN0aW9uIHZlcnRleE1hcEZyb21WZXJ0ZXhOYW1lc0FuZEVkZ2VzKHZlcnRleE5hbWVzLCBlZGdlcykge1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcblxuICB2ZXJ0ZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleE5hbWUpIHtcbiAgICBjb25zdCB2ZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkodmVydGV4TmFtZSk7XG5cbiAgICBpZiAoIXZlcnRleEV4aXN0cykge1xuICAgICAgY29uc3QgdmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKHZlcnRleE5hbWUpO1xuXG4gICAgICB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0gPSB2ZXJ0ZXg7XG4gICAgfVxuICB9KTtcblxuICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICBjb25zdCBzb3VyY2VWZXJ0ZXhOYW1lID0gZWRnZS5nZXRTb3VyY2VWZXJ0ZXhOYW1lKCksXG4gICAgICAgICAgdGFyZ2V0VmVydGV4TmFtZSA9IGVkZ2UuZ2V0VGFyZ2V0VmVydGV4TmFtZSgpLFxuICAgICAgICAgIHNvdXJjZVZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VWZXJ0ZXhOYW1lKSxcbiAgICAgICAgICB0YXJnZXRWZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkodGFyZ2V0VmVydGV4TmFtZSk7XG5cbiAgICBpZiAoIXNvdXJjZVZlcnRleEV4aXN0cykge1xuICAgICAgY29uc3Qgc291cmNlVmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKHNvdXJjZVZlcnRleE5hbWUpO1xuXG4gICAgICB2ZXJ0ZXhNYXBbc291cmNlVmVydGV4TmFtZV0gPSBzb3VyY2VWZXJ0ZXg7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRWZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIGNvbnN0IHRhcmdldFZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZSh0YXJnZXRWZXJ0ZXhOYW1lKTtcblxuICAgICAgdmVydGV4TWFwW3RhcmdldFZlcnRleE5hbWVdID0gdGFyZ2V0VmVydGV4O1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IHZlcnRleE1hcFtzb3VyY2VWZXJ0ZXhOYW1lXSxcbiAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSB2ZXJ0ZXhNYXBbdGFyZ2V0VmVydGV4TmFtZV0sXG4gICAgICAgICAgaW5jb21pbmdFZGdlID0gZWRnZSwgIC8vL1xuICAgICAgICAgIG91dGdvaW5nRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgIHNvdXJjZVZlcnRleC5hZGRPdXRnb2luZ0VkZ2Uob3V0Z29pbmdFZGdlKTtcblxuICAgIHRhcmdldFZlcnRleC5hZGRJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZlcnRleE1hcDtcbn1cblxuZnVuY3Rpb24gdmVydGV4TWFwRnJvbVZlcnRleExpdGVyYWxzKHZlcnRleExpdGVyYWxzKSB7XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBmaXJzdCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICB2ZXJ0ZXhOYW1lID0gZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KHZlcnRleE5hbWUpO1xuXG4gICAgaWYgKCF2ZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIGNvbnN0IHZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZSh2ZXJ0ZXhOYW1lKTtcblxuICAgICAgdmVydGV4TWFwW3ZlcnRleE5hbWVdID0gdmVydGV4O1xuICAgIH1cblxuICAgIGNvbnN0IHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50ID0gc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGFuY2VzdG9yVmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudDsgLy8vXG5cbiAgICBhbmNlc3RvclZlcnRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24oYW5jZXN0b3JWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBhbmNlc3RvclZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eShhbmNlc3RvclZlcnRleE5hbWUpO1xuXG4gICAgICBpZiAoIWFuY2VzdG9yVmVydGV4RXhpc3RzKSB7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKGFuY2VzdG9yVmVydGV4TmFtZSk7XG5cbiAgICAgICAgdmVydGV4TWFwW2FuY2VzdG9yVmVydGV4TmFtZV0gPSBhbmNlc3RvclZlcnRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZlcnRleE1hcDtcbn1cblxuZnVuY3Rpb24gZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAodmVydGV4TGl0ZXJhbHMsIHZlcnRleE1hcCkge1xuICBjb25zdCBlZGdlcyA9IFtdO1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBmaXJzdCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCA9IHNlY29uZCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBhbmNlc3RvclZlcnRleE5hbWVzID0gc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQsIC8vL1xuICAgICAgICAgIHZlcnRleE5hbWUgPSBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50OyAvLy9cblxuICAgIGFuY2VzdG9yVmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbihhbmNlc3RvclZlcnRleE5hbWUpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleE5hbWUgPSBhbmNlc3RvclZlcnRleE5hbWUsIC8vL1xuICAgICAgICAgICAgdGFyZ2V0VmVydGV4TmFtZSA9IHZlcnRleE5hbWUsICAvLy9cbiAgICAgICAgICAgIHNvdXJjZVZlcnRleCA9IHZlcnRleE1hcFtzb3VyY2VWZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgIHRhcmdldFZlcnRleCA9IHZlcnRleE1hcFt0YXJnZXRWZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgIGVkZ2UgPSBuZXcgRWRnZShzb3VyY2VWZXJ0ZXhOYW1lLCB0YXJnZXRWZXJ0ZXhOYW1lKSxcbiAgICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2UsICAvLy9cbiAgICAgICAgICAgIG91dGdvaW5nRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgICAgZWRnZXMucHVzaChlZGdlKTtcblxuICAgICAgc291cmNlVmVydGV4LmFkZE91dGdvaW5nRWRnZShvdXRnb2luZ0VkZ2UpO1xuXG4gICAgICB0YXJnZXRWZXJ0ZXguYWRkSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuZnVuY3Rpb24gdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlc0Zyb21WZXJ0ZXhNYXBBbmRFZGdlcyh2ZXJ0ZXhNYXAsIGVkZ2VzKSB7XG4gIGNvbnN0IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4TmFtZXMgPSBbXSxcbiAgICAgICAgc3RhcnRpbmdWZXJ0ZXhOYW1lcyA9IHN0YXJ0aW5nVmVydGV4TmFtZXNGcm9tVmVydGV4TWFwKHZlcnRleE1hcCksXG4gICAgICAgIHJlbW92ZWRFZGdlcyA9IFtdO1xuXG4gIGxldCBzdGFydGluZ1ZlcnRleE5hbWVzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0ZXhOYW1lcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0aW5nVmVydGV4TmFtZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXhOYW1lID0gc3RhcnRpbmdWZXJ0ZXhOYW1lcy5wb3AoKSxcbiAgICAgICAgICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWUgPSBzdGFydGluZ1ZlcnRleE5hbWU7ICAvLy9cblxuICAgIHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4TmFtZXMucHVzaCh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWUpO1xuXG4gICAgYmFja3dhcmRzRm9yRWFjaChlZGdlcywgZnVuY3Rpb24oZWRnZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleE5hbWUgPSBlZGdlLmdldFNvdXJjZVZlcnRleE5hbWUoKSxcbiAgICAgICAgICAgIGVkZ2VTdGFydGluZyA9IChzb3VyY2VWZXJ0ZXhOYW1lID09PSBzdGFydGluZ1ZlcnRleE5hbWUpOyAvLy9cblxuICAgICAgaWYgKGVkZ2VTdGFydGluZykge1xuICAgICAgICBlZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFZlcnRleE5hbWUgPSBlZGdlLmdldFRhcmdldFZlcnRleE5hbWUoKSxcbiAgICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gdmVydGV4TWFwW3RhcmdldFZlcnRleE5hbWVdLFxuICAgICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSBlZGdlLCAvLy9cbiAgICAgICAgICAgICAgcmVtb3ZlZEVkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgICAgdGFyZ2V0VmVydGV4LnJlbW92ZUluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuXG4gICAgICAgIHJlbW92ZWRFZGdlcy5wdXNoKHJlbW92ZWRFZGdlKTtcblxuICAgICAgICBjb25zdCB0YXJnZXRWZXJ0ZXhTdGFydGluZyA9IHRhcmdldFZlcnRleC5pc1N0YXJ0aW5nKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFZlcnRleFN0YXJ0aW5nKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXhOYW1lID0gdGFyZ2V0VmVydGV4TmFtZTsgIC8vL1xuXG4gICAgICAgICAgc3RhcnRpbmdWZXJ0ZXhOYW1lcy5wdXNoKHN0YXJ0aW5nVmVydGV4TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YXJ0aW5nVmVydGV4TmFtZXNMZW5ndGggPSBzdGFydGluZ1ZlcnRleE5hbWVzLmxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IGVkZ2VzTGVuZ3RoID0gZWRnZXMubGVuZ3RoO1xuXG4gIGlmIChlZGdlc0xlbmd0aCA9PT0gMCkge1xuICAgIHJlbW92ZWRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlbW92ZWRFZGdlKSB7XG4gICAgICBjb25zdCB0YXJnZXRWZXJ0ZXhOYW1lID0gcmVtb3ZlZEVkZ2UuZ2V0VGFyZ2V0VmVydGV4TmFtZSgpLFxuICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gdmVydGV4TWFwW3RhcmdldFZlcnRleE5hbWVdLFxuICAgICAgICAgICAgaW5jb21pbmdFZGdlID0gcmVtb3ZlZEVkZ2U7IC8vL1xuICAgICAgXG4gICAgICB0YXJnZXRWZXJ0ZXguYWRkSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcyA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4TmFtZXMubWFwKGZ1bmN0aW9uKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4TmFtZSkge1xuICAgIGNvbnN0IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4ID0gdmVydGV4TWFwW3RvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4TmFtZV07XG5cbiAgICByZXR1cm4gdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXg7XG4gIH0pO1xuXG4gIHJldHVybiB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXM7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0aW5nVmVydGV4TmFtZXNGcm9tVmVydGV4TWFwKHZlcnRleE1hcCkge1xuICBjb25zdCB2ZXJ0ZXhOYW1lcyA9IE9iamVjdC5rZXlzKHZlcnRleE1hcCksXG4gICAgICAgIHN0YXJ0aW5nVmVydGV4TmFtZXMgPSB2ZXJ0ZXhOYW1lcy5yZWR1Y2UoZnVuY3Rpb24oc3RhcnRpbmdWZXJ0ZXhOYW1lcywgdmVydGV4TmFtZSkge1xuICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTdGFydGluZyA9IHZlcnRleC5pc1N0YXJ0aW5nKCk7XG5cbiAgICAgICAgICBpZiAodmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4TmFtZSA9IHZlcnRleE5hbWU7ICAvLy9cblxuICAgICAgICAgICAgc3RhcnRpbmdWZXJ0ZXhOYW1lcy5wdXNoKHN0YXJ0aW5nVmVydGV4TmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0aW5nVmVydGV4TmFtZXNcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBzdGFydGluZ1ZlcnRleE5hbWVzO1xufVxuIl19