'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(topologicallySortedVertices, remainingEdges) {
    _classCallCheck(this, Graph);

    this.topologicallySortedVertices = topologicallySortedVertices;
    this.remainingEdges = remainingEdges;
  }

  _createClass(Graph, [{
    key: 'getTopologicallySortedVertices',
    value: function getTopologicallySortedVertices() {
      return this.topologicallySortedVertices;
    }
  }, {
    key: 'getRemainingEdges',
    value: function getRemainingEdges() {
      return this.remainingEdges;
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertexMap = vertexMapFromVertexLiterals(vertexLiterals),
          edges = edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap),
          topologicallySortedVertices = topologicallySortedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = edges,
          ///
      graph = new Graph(topologicallySortedVertices, remainingEdges);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function vertexMapFromVertexLiterals(vertexLiterals) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        vertexName = firstVertexLiteralElement,
        ///
    vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }

    var secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (!ancestorVertexExists) {
        var ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;
      }
    });
  });

  return vertexMap;
}

function edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap) {
  var edges = [];

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement,
        ///
    vertex = vertexMap[vertexName];

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertex = vertexMap[ancestorVertexName],
          sourceVertex = ancestorVertex,
          ///
      targetVertex = vertex,
          ///
      edge = new Edge(sourceVertex, targetVertex),
          incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      edges.push(edge);

      vertex.addIncomingEdge(incomingEdge);

      ancestorVertex.addOutgoingEdge(outgoingEdge);
    });
  });

  return edges;
}

function topologicallySortedVerticesFromVertexMapAndEdges(vertexMap, edges) {
  var topologicallySortedVertices = [];

  var startingVertices = startingVerticesFromVertexMap(vertexMap);

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        topologicallySortedVertex = startingVertex; ///

    topologicallySortedVertices.push(topologicallySortedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var sourceVertex = edge.getSourceVertex(),
          edgeStarting = sourceVertex === startingVertex; ///

      if (edgeStarting) {
        edges.splice(index, 1);

        var targetVertex = edge.getTargetVertex(),
            incomingEdge = edge; ///

        targetVertex.removeIncomingEdge(incomingEdge);

        var targetVertexStarting = targetVertex.isStarting();

        if (targetVertexStarting) {
          var _startingVertex = targetVertex; ///

          startingVertices.push(_startingVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength > 0) {
    topologicallySortedVertices = null;
  }

  return topologicallySortedVertices;
}

function startingVerticesFromVertexMap(vertexMap) {
  var vertexNames = Object.keys(vertexMap),
      startingVertices = vertexNames.reduce(function (startingVertices, vertexName) {
    var vertex = vertexMap[vertexName],
        vertexStarting = vertex.isStarting();

    if (vertexStarting) {
      var _startingVertex2 = vertex; ///

      startingVertices.push(_startingVertex2);
    }

    return startingVertices;
  }, []);

  return startingVertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzIiwicmVtYWluaW5nRWRnZXMiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRleE1hcCIsInZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyIsImVkZ2VzIiwiZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAiLCJ0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXMiLCJncmFwaCIsIm1vZHVsZSIsImV4cG9ydHMiLCJmb3JFYWNoIiwidmVydGV4TGl0ZXJhbCIsImZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJmaXJzdCIsInZlcnRleE5hbWUiLCJ2ZXJ0ZXhFeGlzdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInZlcnRleCIsImZyb21WZXJ0ZXhOYW1lIiwic2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJzZWNvbmQiLCJhbmNlc3RvclZlcnRleE5hbWVzIiwiYW5jZXN0b3JWZXJ0ZXhOYW1lIiwiYW5jZXN0b3JWZXJ0ZXhFeGlzdHMiLCJhbmNlc3RvclZlcnRleCIsInNvdXJjZVZlcnRleCIsInRhcmdldFZlcnRleCIsImVkZ2UiLCJpbmNvbWluZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJwdXNoIiwiYWRkSW5jb21pbmdFZGdlIiwiYWRkT3V0Z29pbmdFZGdlIiwic3RhcnRpbmdWZXJ0aWNlcyIsInN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwIiwic3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCIsImxlbmd0aCIsInN0YXJ0aW5nVmVydGV4IiwicG9wIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRleCIsImJhY2t3YXJkc0ZvckVhY2giLCJpbmRleCIsImdldFNvdXJjZVZlcnRleCIsImVkZ2VTdGFydGluZyIsInNwbGljZSIsImdldFRhcmdldFZlcnRleCIsInJlbW92ZUluY29taW5nRWRnZSIsInRhcmdldFZlcnRleFN0YXJ0aW5nIiwiaXNTdGFydGluZyIsImVkZ2VzTGVuZ3RoIiwidmVydGV4TmFtZXMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwidmVydGV4U3RhcnRpbmciXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxPQUFPQyxRQUFRLGNBQVIsQ0FBYjtBQUFBLElBQ01DLFNBQVNELFFBQVEsZ0JBQVIsQ0FEZjtBQUFBLElBRU1FLFlBQVlGLFFBQVEsY0FBUixDQUZsQjs7SUFJTUcsSztBQUNKLGlCQUFhQywyQkFBYixFQUEwQ0MsY0FBMUMsRUFBMEQ7QUFBQTs7QUFDeEQsU0FBS0QsMkJBQUwsR0FBbUNBLDJCQUFuQztBQUNBLFNBQUtDLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0Q7Ozs7cURBRWdDO0FBQy9CLGFBQU8sS0FBS0QsMkJBQVo7QUFDRDs7O3dDQUVtQjtBQUNsQixhQUFPLEtBQUtDLGNBQVo7QUFDRDs7O3VDQUV5QkMsYyxFQUFnQjtBQUN4QyxVQUFNQyxZQUFZQyw0QkFBNEJGLGNBQTVCLENBQWxCO0FBQUEsVUFDTUcsUUFBUUMsb0NBQW9DSixjQUFwQyxFQUFvREMsU0FBcEQsQ0FEZDtBQUFBLFVBRU1ILDhCQUE4Qk8saURBQWlESixTQUFqRCxFQUE0REUsS0FBNUQsQ0FGcEM7QUFBQSxVQUdNSixpQkFBaUJJLEtBSHZCO0FBQUEsVUFHOEI7QUFDeEJHLGNBQVEsSUFBSVQsS0FBSixDQUFVQywyQkFBVixFQUF1Q0MsY0FBdkMsQ0FKZDs7QUFNQSxhQUFPTyxLQUFQO0FBQ0Q7Ozs7OztBQUdIQyxPQUFPQyxPQUFQLEdBQWlCWCxLQUFqQjs7QUFFQSxTQUFTSywyQkFBVCxDQUFxQ0YsY0FBckMsRUFBcUQ7QUFDbkQsTUFBTUMsWUFBWSxFQUFsQjs7QUFFQUQsaUJBQWVTLE9BQWYsQ0FBdUIsVUFBU0MsYUFBVCxFQUF3QjtBQUM3QyxRQUFNQyw0QkFBNEJmLFVBQVVnQixLQUFWLENBQWdCRixh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IHJlcXVpcmUoJy4vZ3JhcGgvZWRnZScpLFxuICAgICAgVmVydGV4ID0gcmVxdWlyZSgnLi9ncmFwaC92ZXJ0ZXgnKSxcbiAgICAgIGFycmF5VXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9hcnJheScpO1xuXG5jbGFzcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yICh0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gICAgdGhpcy50b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMgPSB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXM7XG4gICAgdGhpcy5yZW1haW5pbmdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzO1xuICB9XG5cbiAgZ2V0VG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcztcbiAgfVxuXG4gIGdldFJlbWFpbmluZ0VkZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnJlbWFpbmluZ0VkZ2VzO1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscykge1xuICAgIGNvbnN0IHZlcnRleE1hcCA9IHZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscyksXG4gICAgICAgICAgZWRnZXMgPSBlZGdlc0Zyb21WZXJ0ZXhMaXRlcmFsc0FuZFZlcnRleE1hcCh2ZXJ0ZXhMaXRlcmFscywgdmVydGV4TWFwKSxcbiAgICAgICAgICB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMgPSB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcyksXG4gICAgICAgICAgcmVtYWluaW5nRWRnZXMgPSBlZGdlcywgLy8vXG4gICAgICAgICAgZ3JhcGggPSBuZXcgR3JhcGgodG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzLCByZW1haW5pbmdFZGdlcyk7XG4gICAgXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG5cbmZ1bmN0aW9uIHZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscykge1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcblxuICB2ZXJ0ZXhMaXRlcmFscy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleExpdGVyYWwpIHtcbiAgICBjb25zdCBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLmZpcnN0KHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIHZlcnRleE5hbWUgPSBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkodmVydGV4TmFtZSk7XG5cbiAgICBpZiAoIXZlcnRleEV4aXN0cykge1xuICAgICAgY29uc3QgdmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKHZlcnRleE5hbWUpO1xuXG4gICAgICB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0gPSB2ZXJ0ZXg7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGFuY2VzdG9yVmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudDsgLy8vXG5cbiAgICBhbmNlc3RvclZlcnRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24oYW5jZXN0b3JWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBhbmNlc3RvclZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eShhbmNlc3RvclZlcnRleE5hbWUpO1xuXG4gICAgICBpZiAoIWFuY2VzdG9yVmVydGV4RXhpc3RzKSB7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKGFuY2VzdG9yVmVydGV4TmFtZSk7XG5cbiAgICAgICAgdmVydGV4TWFwW2FuY2VzdG9yVmVydGV4TmFtZV0gPSBhbmNlc3RvclZlcnRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZlcnRleE1hcDtcbn1cblxuZnVuY3Rpb24gZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAodmVydGV4TGl0ZXJhbHMsIHZlcnRleE1hcCkge1xuICBjb25zdCBlZGdlcyA9IFtdO1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGFuY2VzdG9yVmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4TmFtZSA9IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQsIC8vL1xuICAgICAgICAgIHZlcnRleCA9IHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcblxuICAgIGFuY2VzdG9yVmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbihhbmNlc3RvclZlcnRleE5hbWUpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4ID0gdmVydGV4TWFwW2FuY2VzdG9yVmVydGV4TmFtZV0sXG4gICAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSBhbmNlc3RvclZlcnRleCwgLy8vXG4gICAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSB2ZXJ0ZXgsICAvLy9cbiAgICAgICAgICAgIGVkZ2UgPSBuZXcgRWRnZShzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCksXG4gICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSBlZGdlLCAgLy8vXG4gICAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG5cbiAgICAgIHZlcnRleC5hZGRJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcblxuICAgICAgYW5jZXN0b3JWZXJ0ZXguYWRkT3V0Z29pbmdFZGdlKG91dGdvaW5nRWRnZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuZnVuY3Rpb24gdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzRnJvbVZlcnRleE1hcEFuZEVkZ2VzKHZlcnRleE1hcCwgZWRnZXMpIHtcbiAgbGV0IHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcyA9IFtdO1xuXG4gIGNvbnN0IHN0YXJ0aW5nVmVydGljZXMgPSBzdGFydGluZ1ZlcnRpY2VzRnJvbVZlcnRleE1hcCh2ZXJ0ZXhNYXApO1xuXG4gIGxldCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSBzdGFydGluZ1ZlcnRpY2VzLnBvcCgpLFxuICAgICAgICAgIHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0ZXggPSBzdGFydGluZ1ZlcnRleDsgIC8vL1xuXG4gICAgdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzLnB1c2godG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRleCk7XG5cbiAgICBhcnJheVV0aWwuYmFja3dhcmRzRm9yRWFjaChlZGdlcywgZnVuY3Rpb24oZWRnZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IGVkZ2UuZ2V0U291cmNlVmVydGV4KCksXG4gICAgICAgICAgICBlZGdlU3RhcnRpbmcgPSAoc291cmNlVmVydGV4ID09PSBzdGFydGluZ1ZlcnRleCk7IC8vL1xuXG4gICAgICBpZiAoZWRnZVN0YXJ0aW5nKSB7XG4gICAgICAgIGVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0VmVydGV4ID0gZWRnZS5nZXRUYXJnZXRWZXJ0ZXgoKSxcbiAgICAgICAgICAgICAgaW5jb21pbmdFZGdlID0gZWRnZTsgIC8vL1xuXG4gICAgICAgIHRhcmdldFZlcnRleC5yZW1vdmVJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcblxuICAgICAgICBjb25zdCB0YXJnZXRWZXJ0ZXhTdGFydGluZyA9IHRhcmdldFZlcnRleC5pc1N0YXJ0aW5nKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFZlcnRleFN0YXJ0aW5nKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSB0YXJnZXRWZXJ0ZXg7ICAvLy9cblxuICAgICAgICAgIHN0YXJ0aW5nVmVydGljZXMucHVzaChzdGFydGluZ1ZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPSBzdGFydGluZ1ZlcnRpY2VzLmxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IGVkZ2VzTGVuZ3RoID0gZWRnZXMubGVuZ3RoO1xuXG4gIGlmIChlZGdlc0xlbmd0aCA+IDApIHtcbiAgICB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gc3RhcnRpbmdWZXJ0aWNlc0Zyb21WZXJ0ZXhNYXAodmVydGV4TWFwKSB7XG4gIGNvbnN0IHZlcnRleE5hbWVzID0gT2JqZWN0LmtleXModmVydGV4TWFwKSxcbiAgICAgICAgc3RhcnRpbmdWZXJ0aWNlcyA9IHZlcnRleE5hbWVzLnJlZHVjZShmdW5jdGlvbihzdGFydGluZ1ZlcnRpY2VzLCB2ZXJ0ZXhOYW1lKSB7XG4gICAgICAgICAgY29uc3QgdmVydGV4ID0gdmVydGV4TWFwW3ZlcnRleE5hbWVdLFxuICAgICAgICAgICAgICB2ZXJ0ZXhTdGFydGluZyA9IHZlcnRleC5pc1N0YXJ0aW5nKCk7XG5cbiAgICAgICAgICBpZiAodmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4ID0gdmVydGV4OyAgLy8vXG5cbiAgICAgICAgICAgIHN0YXJ0aW5nVmVydGljZXMucHVzaChzdGFydGluZ1ZlcnRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0aW5nVmVydGljZXNcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBzdGFydGluZ1ZlcnRpY2VzO1xufVxuIl19