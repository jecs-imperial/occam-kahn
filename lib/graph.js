'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(topologicallySortedVertices, remainingEdges, edges) {
    _classCallCheck(this, Graph);

    this.topologicallySortedVertices = topologicallySortedVertices;
    this.remainingEdges = remainingEdges;
    this.edges = edges;
  }

  _createClass(Graph, [{
    key: 'getTopologicallySortedVertices',
    value: function getTopologicallySortedVertices() {
      return this.topologicallySortedVertices;
    }
  }, {
    key: 'getRemainingEdges',
    value: function getRemainingEdges() {
      return this.remainingEdges;
    }
  }, {
    key: 'getEdges',
    value: function getEdges() {
      return this.edges;
    }
  }, {
    key: 'areCyclesPresent',
    value: function areCyclesPresent() {
      var remainingEdgesLength = this.remainingEdges.length,
          cyclesPresent = remainingEdgesLength !== 0;

      return cyclesPresent;
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertexMap = vertexMapFromVertexLiterals(vertexLiterals),
          edges = edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap),
          topologicallySortedVertices = topologicallySortedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = edges,
          ///
      graph = new Graph(topologicallySortedVertices, remainingEdges, edges);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function vertexMapFromVertexLiterals(vertexLiterals) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        vertexName = firstVertexLiteralElement,
        ///
    vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }

    var secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (!ancestorVertexExists) {
        var ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;
      }
    });
  });

  return vertexMap;
}

function edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap) {
  var edges = [];

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement,
        ///
    vertex = vertexMap[vertexName];

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertex = vertexMap[ancestorVertexName],
          sourceVertex = ancestorVertex,
          ///
      targetVertex = vertex,
          ///
      edge = new Edge(sourceVertex, targetVertex),
          incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      edges.push(edge);

      sourceVertex.addOutgoingEdge(outgoingEdge);

      targetVertex.addIncomingEdge(incomingEdge);
    });
  });

  return edges;
}

function topologicallySortedVerticesFromVertexMapAndEdges(vertexMap, edges) {
  var topologicallySortedVertices = [];

  var startingVertices = startingVerticesFromVertexMap(vertexMap),
      removedEdges = [];

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        topologicallySortedVertex = startingVertex; ///

    topologicallySortedVertices.push(topologicallySortedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var sourceVertex = edge.getSourceVertex(),
          edgeStarting = sourceVertex === startingVertex; ///

      if (edgeStarting) {
        edges.splice(index, 1);

        var targetVertex = edge.getTargetVertex(),
            incomingEdge = edge,
            ///
        removedEdge = edge; ///

        targetVertex.removeIncomingEdge(incomingEdge);

        removedEdges.push(removedEdge);

        var targetVertexStarting = targetVertex.isStarting();

        if (targetVertexStarting) {
          var _startingVertex = targetVertex; ///

          startingVertices.push(_startingVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength === 0) {
    removedEdges.forEach(function (removedEdge) {
      var targetVertex = removedEdge.getTargetVertex(),
          incomingEdge = removedEdge,
          ///
      edge = removedEdge; ///

      targetVertex.addIncomingEdge(incomingEdge);

      edges.push(edge);
    });
  }

  return topologicallySortedVertices;
}

function startingVerticesFromVertexMap(vertexMap) {
  var vertexNames = Object.keys(vertexMap),
      startingVertices = vertexNames.reduce(function (startingVertices, vertexName) {
    var vertex = vertexMap[vertexName],
        vertexStarting = vertex.isStarting();

    if (vertexStarting) {
      var _startingVertex2 = vertex; ///

      startingVertices.push(_startingVertex2);
    }

    return startingVertices;
  }, []);

  return startingVertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzIiwicmVtYWluaW5nRWRnZXMiLCJlZGdlcyIsInJlbWFpbmluZ0VkZ2VzTGVuZ3RoIiwibGVuZ3RoIiwiY3ljbGVzUHJlc2VudCIsInZlcnRleExpdGVyYWxzIiwidmVydGV4TWFwIiwidmVydGV4TWFwRnJvbVZlcnRleExpdGVyYWxzIiwiZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAiLCJ0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXMiLCJncmFwaCIsIm1vZHVsZSIsImV4cG9ydHMiLCJmb3JFYWNoIiwidmVydGV4TGl0ZXJhbCIsImZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJmaXJzdCIsInZlcnRleE5hbWUiLCJ2ZXJ0ZXhFeGlzdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInZlcnRleCIsImZyb21WZXJ0ZXhOYW1lIiwic2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJzZWNvbmQiLCJhbmNlc3RvclZlcnRleE5hbWVzIiwiYW5jZXN0b3JWZXJ0ZXhOYW1lIiwiYW5jZXN0b3JWZXJ0ZXhFeGlzdHMiLCJhbmNlc3RvclZlcnRleCIsInNvdXJjZVZlcnRleCIsInRhcmdldFZlcnRleCIsImVkZ2UiLCJpbmNvbWluZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJwdXNoIiwiYWRkT3V0Z29pbmdFZGdlIiwiYWRkSW5jb21pbmdFZGdlIiwic3RhcnRpbmdWZXJ0aWNlcyIsInN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwIiwicmVtb3ZlZEVkZ2VzIiwic3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCIsInN0YXJ0aW5nVmVydGV4IiwicG9wIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRleCIsImJhY2t3YXJkc0ZvckVhY2giLCJpbmRleCIsImdldFNvdXJjZVZlcnRleCIsImVkZ2VTdGFydGluZyIsInNwbGljZSIsImdldFRhcmdldFZlcnRleCIsInJlbW92ZWRFZGdlIiwicmVtb3ZlSW5jb21pbmdFZGdlIiwidGFyZ2V0VmVydGV4U3RhcnRpbmciLCJpc1N0YXJ0aW5nIiwiZWRnZXNMZW5ndGgiLCJ2ZXJ0ZXhOYW1lcyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJ2ZXJ0ZXhTdGFydGluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBLElBQU1BLE9BQU9DLFFBQVEsY0FBUixDQUFiO0FBQUEsSUFDTUMsU0FBU0QsUUFBUSxnQkFBUixDQURmO0FBQUEsSUFFTUUsWUFBWUYsUUFBUSxjQUFSLENBRmxCOztJQUlNRyxLO0FBQ0osaUJBQWFDLDJCQUFiLEVBQTBDQyxjQUExQyxFQUEwREMsS0FBMUQsRUFBaUU7QUFBQTs7QUFDL0QsU0FBS0YsMkJBQUwsR0FBbUNBLDJCQUFuQztBQUNBLFNBQUtDLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhQSxLQUFiO0FBQ0Q7Ozs7cURBRWdDO0FBQy9CLGFBQU8sS0FBS0YsMkJBQVo7QUFDRDs7O3dDQUVtQjtBQUNsQixhQUFPLEtBQUtDLGNBQVo7QUFDRDs7OytCQUVVO0FBQ1QsYUFBTyxLQUFLQyxLQUFaO0FBQ0Q7Ozt1Q0FFa0I7QUFDakIsVUFBTUMsdUJBQXVCLEtBQUtGLGNBQUwsQ0FBb0JHLE1BQWpEO0FBQUEsVUFDTUMsZ0JBQWlCRix5QkFBeUIsQ0FEaEQ7O0FBR0EsYUFBT0UsYUFBUDtBQUNEOzs7dUNBRXlCQyxjLEVBQWdCO0FBQ3hDLFVBQU1DLFlBQVlDLDRCQUE0QkYsY0FBNUIsQ0FBbEI7QUFBQSxVQUNNSixRQUFRTyxvQ0FBb0NILGNBQXBDLEVBQW9EQyxTQUFwRCxDQURkO0FBQUEsVUFFTVAsOEJBQThCVSxpREFBaURILFNBQWpELEVBQTRETCxLQUE1RCxDQUZwQztBQUFBLFVBR01ELGlCQUFpQkMsS0FIdkI7QUFBQSxVQUc4QjtBQUN4QlMsY0FBUSxJQUFJWixLQUFKLENBQVVDLDJCQUFWLEVBQXVDQyxjQUF2QyxFQUF1REMsS0FBdkQsQ0FKZDs7QUFNQSxhQUFPUyxLQUFQO0FBQ0Q7Ozs7OztBQUdIQyxPQUFPQyxPQUFQLEdBQWlCZCxLQUFqQjs7QUFFQSxTQUFTUywyQkFBVCxDQUFxQ0YsY0FBckMsRUFBcUQ7QUFDbkQsTUFBTUMsWUFBWSxFQUFsQjs7QUFFQUQsaUJBQWVRLE9BQWYsQ0FBdUIsVUFBU0MsYUFBVCxFQUF3QjtBQUM3QyxRQUFNQyw0QkFBNEJsQixVQUFVbUIsS0FBVixDQUFnQkYsYUFBaEIsQ0FBbEM7QUFBQSxRQUNNRyxhQUFhRix5QkFEbkI7QUFBQSxRQUM4QztBQUN4Q0csbUJBQWVaLFVBQVVhLGNBQVYsQ0FBeUJGLFVBQXpCLENBRnJCOztBQUlBLFFBQUksQ0FBQ0MsWUFBTCxFQUFtQjtBQUNqQixVQUFNRSxTQUFTeEIsT0FBT3lCLGNBQVAsQ0FBc0JKLFVBQXRCLENBQWY7O0FBRUFYLGdCQUFVVyxVQUFWLElBQXdCRyxNQUF4QjtBQUNEOztBQUVELFFBQU1FLDZCQUE2QnpCLFVBQVUwQixNQUFWLENBQWlCVCxhQUFqQixDQUFuQztBQUFBLFFBQ01VLHNCQUFzQkYsMEJBRDVCLENBWDZDLENBWVc7O0FBRXhERSx3QkFBb0JYLE9BQXBCLENBQTRCLFVBQVNZLGtCQUFULEVBQTZCO0FBQ3ZELFVBQU1DLHVCQUF1QnBCLFVBQVVhLGNBQVYsQ0FBeUJNLGtCQUF6QixDQUE3Qjs7QUFFQSxVQUFJLENBQUNDLG9CQUFMLEVBQTJCO0FBQ3pCLFlBQU1DLGlCQUFpQi9CLE9BQU95QixjQUFQLENBQXNCSSxrQkFBdEIsQ0FBdkI7O0FBRUFuQixrQkFBVW1CLGtCQUFWLElBQWdDRSxjQUFoQztBQUNEO0FBQ0YsS0FSRDtBQVNELEdBdkJEOztBQXlCQSxTQUFPckIsU0FBUDtBQUNEOztBQUVELFNBQVNFLG1DQUFULENBQTZDSCxjQUE3QyxFQUE2REMsU0FBN0QsRUFBd0U7QUFDdEUsTUFBTUwsUUFBUSxFQUFkOztBQUVBSSxpQkFBZVEsT0FBZixDQUF1QixVQUFTQyxhQUFULEVBQXdCO0FBQzdDLFFBQU1DLDRCQUE0QmxCLFVBQVVtQixLQUFWLENBQWdCRixhQUFoQixDQUFsQztBQUFBLFFBQ01RLDZCQUE2QnpCLFVBQVUwQixNQUFWLENBQWlCVCxhQUFqQixDQURuQztBQUFBLFFBRU1VLHNCQUFzQkYsMEJBRjVCO0FBQUEsUUFFd0Q7QUFDbERMLGlCQUFhRix5QkFIbkI7QUFBQSxRQUc4QztBQUN4Q0ssYUFBU2QsVUFBVVcsVUFBVixDQUpmOztBQU1BTyx3QkFBb0JYLE9BQXBCLENBQTRCLFVBQVNZLGtCQUFULEVBQTZCO0FBQ3ZELFVBQU1FLGlCQUFpQnJCLFVBQVVtQixrQkFBVixDQUF2QjtBQUFBLFVBQ01HLGVBQWVELGNBRHJCO0FBQUEsVUFDcUM7QUFDL0JFLHFCQUFlVCxNQUZyQjtBQUFBLFVBRThCO0FBQ3hCVSxhQUFPLElBQUlwQyxJQUFKLENBQVNrQyxZQUFULEVBQXVCQyxZQUF2QixDQUhiO0FBQUEsVUFJTUUsZUFBZUQsSUFKckI7QUFBQSxVQUk0QjtBQUN0QkUscUJBQWVGLElBTHJCLENBRHVELENBTTNCOztBQUU1QjdCLFlBQU1nQyxJQUFOLENBQVdILElBQVg7O0FBRUFGLG1CQUFhTSxlQUFiLENBQTZCRixZQUE3Qjs7QUFFQUgsbUJBQWFNLGVBQWIsQ0FBNkJKLFlBQTdCO0FBQ0QsS0FiRDtBQWNELEdBckJEOztBQXVCQSxTQUFPOUIsS0FBUDtBQUNEOztBQUVELFNBQVNRLGdEQUFULENBQTBESCxTQUExRCxFQUFxRUwsS0FBckUsRUFBNEU7QUFDMUUsTUFBSUYsOEJBQThCLEVBQWxDOztBQUVBLE1BQU1xQyxtQkFBbUJDLDhCQUE4Qi9CLFNBQTlCLENBQXpCO0FBQUEsTUFDTWdDLGVBQWUsRUFEckI7O0FBR0EsTUFBSUMseUJBQXlCSCxpQkFBaUJqQyxNQUE5Qzs7QUFOMEU7QUFTeEUsUUFBTXFDLGlCQUFpQkosaUJBQWlCSyxHQUFqQixFQUF2QjtBQUFBLFFBQ01DLDRCQUE0QkYsY0FEbEMsQ0FUd0UsQ0FVckI7O0FBRW5EekMsZ0NBQTRCa0MsSUFBNUIsQ0FBaUNTLHlCQUFqQzs7QUFFQTdDLGNBQVU4QyxnQkFBVixDQUEyQjFDLEtBQTNCLEVBQWtDLFVBQVM2QixJQUFULEVBQWVjLEtBQWYsRUFBc0I7QUFDdEQsVUFBTWhCLGVBQWVFLEtBQUtlLGVBQUwsRUFBckI7QUFBQSxVQUNNQyxlQUFnQmxCLGlCQUFpQlksY0FEdkMsQ0FEc0QsQ0FFRTs7QUFFeEQsVUFBSU0sWUFBSixFQUFrQjtBQUNoQjdDLGNBQU04QyxNQUFOLENBQWFILEtBQWIsRUFBb0IsQ0FBcEI7O0FBRUEsWUFBTWYsZUFBZUMsS0FBS2tCLGVBQUwsRUFBckI7QUFBQSxZQUNNakIsZUFBZUQsSUFEckI7QUFBQSxZQUMyQjtBQUNyQm1CLHNCQUFjbkIsSUFGcEIsQ0FIZ0IsQ0FLVzs7QUFFM0JELHFCQUFhcUIsa0JBQWIsQ0FBZ0NuQixZQUFoQzs7QUFFQU8scUJBQWFMLElBQWIsQ0FBa0JnQixXQUFsQjs7QUFFQSxZQUFNRSx1QkFBdUJ0QixhQUFhdUIsVUFBYixFQUE3Qjs7QUFFQSxZQUFJRCxvQkFBSixFQUEwQjtBQUN4QixjQUFNWCxrQkFBaUJYLFlBQXZCLENBRHdCLENBQ2M7O0FBRXRDTywyQkFBaUJILElBQWpCLENBQXNCTyxlQUF0QjtBQUNEO0FBQ0Y7QUFDRixLQXZCRDs7QUF5QkFELDZCQUF5QkgsaUJBQWlCakMsTUFBMUM7QUF2Q3dFOztBQVExRSxTQUFPb0MseUJBQXlCLENBQWhDLEVBQW1DO0FBQUE7QUFnQ2xDOztBQUVELE1BQU1jLGNBQWNwRCxNQUFNRSxNQUExQjs7QUFFQSxNQUFJa0QsZ0JBQWdCLENBQXBCLEVBQXVCO0FBQ3JCZixpQkFBYXpCLE9BQWIsQ0FBcUIsVUFBU29DLFdBQVQsRUFBc0I7QUFDekMsVUFBTXBCLGVBQWVvQixZQUFZRCxlQUFaLEVBQXJCO0FBQUEsVUFDTWpCLGVBQWVrQixXQURyQjtBQUFBLFVBQ2tDO0FBQzVCbkIsYUFBT21CLFdBRmIsQ0FEeUMsQ0FHZjs7QUFFMUJwQixtQkFBYU0sZUFBYixDQUE2QkosWUFBN0I7O0FBRUE5QixZQUFNZ0MsSUFBTixDQUFXSCxJQUFYO0FBQ0QsS0FSRDtBQVNEOztBQUVELFNBQU8vQiwyQkFBUDtBQUNEOztBQUVELFNBQVNzQyw2QkFBVCxDQUF1Qy9CLFNBQXZDLEVBQWtEO0FBQ2hELE1BQU1nRCxjQUFjQyxPQUFPQyxJQUFQLENBQVlsRCxTQUFaLENBQXBCO0FBQUEsTUFDTThCLG1CQUFtQmtCLFlBQVlHLE1BQVosQ0FBbUIsVUFBU3JCLGdCQUFULEVBQTJCbkIsVUFBM0IsRUFBdUM7QUFDM0UsUUFBTUcsU0FBU2QsVUFBVVcsVUFBVixDQUFmO0FBQUEsUUFDTXlDLGlCQUFpQnRDLE9BQU9nQyxVQUFQLEVBRHZCOztBQUdBLFFBQUlNLGNBQUosRUFBb0I7QUFDbEIsVUFBTWxCLG1CQUFpQnBCLE1BQXZCLENBRGtCLENBQ2M7O0FBRWhDZ0IsdUJBQWlCSCxJQUFqQixDQUFzQk8sZ0JBQXRCO0FBQ0Q7O0FBRUQsV0FBT0osZ0JBQVA7QUFDRCxHQVhrQixFQVdoQixFQVhnQixDQUR6Qjs7QUFjQSxTQUFPQSxnQkFBUDtBQUNEIiwiZmlsZSI6ImdyYXBoLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFZGdlID0gcmVxdWlyZSgnLi9ncmFwaC9lZGdlJyksXG4gICAgICBWZXJ0ZXggPSByZXF1aXJlKCcuL2dyYXBoL3ZlcnRleCcpLFxuICAgICAgYXJyYXlVdGlsID0gcmVxdWlyZSgnLi91dGlsL2FycmF5Jyk7XG5cbmNsYXNzIEdyYXBoIHtcbiAgY29uc3RydWN0b3IgKHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcywgcmVtYWluaW5nRWRnZXMsIGVkZ2VzKSB7XG4gICAgdGhpcy50b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMgPSB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXM7XG4gICAgdGhpcy5yZW1haW5pbmdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzO1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgfVxuXG4gIGdldFRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXM7XG4gIH1cblxuICBnZXRSZW1haW5pbmdFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmdFZGdlcztcbiAgfVxuICBcbiAgZ2V0RWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXM7XG4gIH1cbiAgXG4gIGFyZUN5Y2xlc1ByZXNlbnQoKSB7XG4gICAgY29uc3QgcmVtYWluaW5nRWRnZXNMZW5ndGggPSB0aGlzLnJlbWFpbmluZ0VkZ2VzLmxlbmd0aCxcbiAgICAgICAgICBjeWNsZXNQcmVzZW50ID0gKHJlbWFpbmluZ0VkZ2VzTGVuZ3RoICE9PSAwKTtcbiAgICBcbiAgICByZXR1cm4gY3ljbGVzUHJlc2VudDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhNYXAgPSB2ZXJ0ZXhNYXBGcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpLFxuICAgICAgICAgIGVkZ2VzID0gZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAodmVydGV4TGl0ZXJhbHMsIHZlcnRleE1hcCksXG4gICAgICAgICAgdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzID0gdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzRnJvbVZlcnRleE1hcEFuZEVkZ2VzKHZlcnRleE1hcCwgZWRnZXMpLFxuICAgICAgICAgIHJlbWFpbmluZ0VkZ2VzID0gZWRnZXMsIC8vL1xuICAgICAgICAgIGdyYXBoID0gbmV3IEdyYXBoKHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcywgcmVtYWluaW5nRWRnZXMsIGVkZ2VzKTtcblxuICAgIHJldHVybiBncmFwaDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoO1xuXG5mdW5jdGlvbiB2ZXJ0ZXhNYXBGcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpIHtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG5cbiAgdmVydGV4TGl0ZXJhbHMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXhMaXRlcmFsKSB7XG4gICAgY29uc3QgZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCA9IGFycmF5VXRpbC5maXJzdCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICB2ZXJ0ZXhOYW1lID0gZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KHZlcnRleE5hbWUpO1xuXG4gICAgaWYgKCF2ZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIGNvbnN0IHZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZSh2ZXJ0ZXhOYW1lKTtcblxuICAgICAgdmVydGV4TWFwW3ZlcnRleE5hbWVdID0gdmVydGV4O1xuICAgIH1cblxuICAgIGNvbnN0IHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLnNlY29uZCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBhbmNlc3RvclZlcnRleE5hbWVzID0gc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQ7IC8vL1xuXG4gICAgYW5jZXN0b3JWZXJ0ZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFuY2VzdG9yVmVydGV4TmFtZSkge1xuICAgICAgY29uc3QgYW5jZXN0b3JWZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkoYW5jZXN0b3JWZXJ0ZXhOYW1lKTtcblxuICAgICAgaWYgKCFhbmNlc3RvclZlcnRleEV4aXN0cykge1xuICAgICAgICBjb25zdCBhbmNlc3RvclZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZShhbmNlc3RvclZlcnRleE5hbWUpO1xuXG4gICAgICAgIHZlcnRleE1hcFthbmNlc3RvclZlcnRleE5hbWVdID0gYW5jZXN0b3JWZXJ0ZXg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJ0ZXhNYXA7XG59XG5cbmZ1bmN0aW9uIGVkZ2VzRnJvbVZlcnRleExpdGVyYWxzQW5kVmVydGV4TWFwKHZlcnRleExpdGVyYWxzLCB2ZXJ0ZXhNYXApIHtcbiAgY29uc3QgZWRnZXMgPSBbXTtcblxuICB2ZXJ0ZXhMaXRlcmFscy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleExpdGVyYWwpIHtcbiAgICBjb25zdCBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLmZpcnN0KHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLnNlY29uZCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBhbmNlc3RvclZlcnRleE5hbWVzID0gc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQsIC8vL1xuICAgICAgICAgIHZlcnRleE5hbWUgPSBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXggPSB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV07XG5cbiAgICBhbmNlc3RvclZlcnRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24oYW5jZXN0b3JWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBhbmNlc3RvclZlcnRleCA9IHZlcnRleE1hcFthbmNlc3RvclZlcnRleE5hbWVdLFxuICAgICAgICAgICAgc291cmNlVmVydGV4ID0gYW5jZXN0b3JWZXJ0ZXgsIC8vL1xuICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gdmVydGV4LCAgLy8vXG4gICAgICAgICAgICBlZGdlID0gbmV3IEVkZ2Uoc291cmNlVmVydGV4LCB0YXJnZXRWZXJ0ZXgpLFxuICAgICAgICAgICAgaW5jb21pbmdFZGdlID0gZWRnZSwgIC8vL1xuICAgICAgICAgICAgb3V0Z29pbmdFZGdlID0gZWRnZTsgIC8vL1xuXG4gICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICBzb3VyY2VWZXJ0ZXguYWRkT3V0Z29pbmdFZGdlKG91dGdvaW5nRWRnZSk7XG5cbiAgICAgIHRhcmdldFZlcnRleC5hZGRJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG5mdW5jdGlvbiB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcykge1xuICBsZXQgdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzID0gW107XG5cbiAgY29uc3Qgc3RhcnRpbmdWZXJ0aWNlcyA9IHN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwKHZlcnRleE1hcCksXG4gICAgICAgIHJlbW92ZWRFZGdlcyA9IFtdO1xuXG4gIGxldCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSBzdGFydGluZ1ZlcnRpY2VzLnBvcCgpLFxuICAgICAgICAgIHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0ZXggPSBzdGFydGluZ1ZlcnRleDsgIC8vL1xuXG4gICAgdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzLnB1c2godG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRleCk7XG5cbiAgICBhcnJheVV0aWwuYmFja3dhcmRzRm9yRWFjaChlZGdlcywgZnVuY3Rpb24oZWRnZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IGVkZ2UuZ2V0U291cmNlVmVydGV4KCksXG4gICAgICAgICAgICBlZGdlU3RhcnRpbmcgPSAoc291cmNlVmVydGV4ID09PSBzdGFydGluZ1ZlcnRleCk7IC8vL1xuXG4gICAgICBpZiAoZWRnZVN0YXJ0aW5nKSB7XG4gICAgICAgIGVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0VmVydGV4ID0gZWRnZS5nZXRUYXJnZXRWZXJ0ZXgoKSxcbiAgICAgICAgICAgICAgaW5jb21pbmdFZGdlID0gZWRnZSwgLy8vXG4gICAgICAgICAgICAgIHJlbW92ZWRFZGdlID0gZWRnZTsgIC8vL1xuXG4gICAgICAgIHRhcmdldFZlcnRleC5yZW1vdmVJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcblxuICAgICAgICByZW1vdmVkRWRnZXMucHVzaChyZW1vdmVkRWRnZSk7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0VmVydGV4U3RhcnRpbmcgPSB0YXJnZXRWZXJ0ZXguaXNTdGFydGluZygpO1xuXG4gICAgICAgIGlmICh0YXJnZXRWZXJ0ZXhTdGFydGluZykge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4ID0gdGFyZ2V0VmVydGV4OyAgLy8vXG5cbiAgICAgICAgICBzdGFydGluZ1ZlcnRpY2VzLnB1c2goc3RhcnRpbmdWZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG4gIH1cblxuICBjb25zdCBlZGdlc0xlbmd0aCA9IGVkZ2VzLmxlbmd0aDtcblxuICBpZiAoZWRnZXNMZW5ndGggPT09IDApIHtcbiAgICByZW1vdmVkRWRnZXMuZm9yRWFjaChmdW5jdGlvbihyZW1vdmVkRWRnZSkge1xuICAgICAgY29uc3QgdGFyZ2V0VmVydGV4ID0gcmVtb3ZlZEVkZ2UuZ2V0VGFyZ2V0VmVydGV4KCksXG4gICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSByZW1vdmVkRWRnZSwgLy8vXG4gICAgICAgICAgICBlZGdlID0gcmVtb3ZlZEVkZ2U7IC8vL1xuICAgICAgXG4gICAgICB0YXJnZXRWZXJ0ZXguYWRkSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG4gICAgICBcbiAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXM7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwKHZlcnRleE1hcCkge1xuICBjb25zdCB2ZXJ0ZXhOYW1lcyA9IE9iamVjdC5rZXlzKHZlcnRleE1hcCksXG4gICAgICAgIHN0YXJ0aW5nVmVydGljZXMgPSB2ZXJ0ZXhOYW1lcy5yZWR1Y2UoZnVuY3Rpb24oc3RhcnRpbmdWZXJ0aWNlcywgdmVydGV4TmFtZSkge1xuICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTdGFydGluZyA9IHZlcnRleC5pc1N0YXJ0aW5nKCk7XG5cbiAgICAgICAgICBpZiAodmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4ID0gdmVydGV4OyAgLy8vXG5cbiAgICAgICAgICAgIHN0YXJ0aW5nVmVydGljZXMucHVzaChzdGFydGluZ1ZlcnRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0YXJ0aW5nVmVydGljZXNcbiAgICAgICAgfSwgW10pO1xuXG4gIHJldHVybiBzdGFydGluZ1ZlcnRpY2VzO1xufVxuIl19