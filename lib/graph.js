'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var necessary = require('necessary');

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    RemainingEdges = require('./graph/remainingEdges');

var arrayUtilities = necessary.arrayUtilities,
    first = arrayUtilities.first,
    second = arrayUtilities.second,
    backwardsForEach = arrayUtilities.backwardsForEach;

var Graph = function () {
  function Graph(topologicallyOrderedVertices, remainingEdges) {
    _classCallCheck(this, Graph);

    this.topologicallyOrderedVertices = topologicallyOrderedVertices;
    this.remainingEdges = remainingEdges;
  }

  _createClass(Graph, [{
    key: 'getTopologicallyOrderedVertices',
    value: function getTopologicallyOrderedVertices() {
      return this.topologicallyOrderedVertices;
    }
  }, {
    key: 'getRemainingEdges',
    value: function getRemainingEdges() {
      return this.remainingEdges;
    }
  }, {
    key: 'areCyclesPresent',
    value: function areCyclesPresent() {
      return this.remainingEdges.areCyclesPresent();
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertexMap = vertexMapFromVertexLiterals(vertexLiterals),
          edges = edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap),
          topologicallyOrderedVertices = topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = new RemainingEdges(edges),
          graph = new Graph(topologicallyOrderedVertices, remainingEdges);

      return graph;
    }
  }, {
    key: 'fromVertexNamesAndEdges',
    value: function fromVertexNamesAndEdges(vertexNames, edges) {
      edges = edges.slice(); ///

      var vertexMap = vertexMapFromVertexNamesAndEdges(vertexNames, edges),
          topologicallyOrderedVertices = topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = new RemainingEdges(edges),
          graph = new Graph(topologicallyOrderedVertices, remainingEdges);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function vertexMapFromVertexNamesAndEdges(vertexNames, edges) {
  var vertexMap = {};

  vertexNames.forEach(function (vertexName) {
    var vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }
  });

  edges.forEach(function (edge) {
    var sourceVertexName = edge.getSourceVertexName(),
        targetVertexName = edge.getTargetVertexName(),
        sourceVertexExists = vertexMap.hasOwnProperty(sourceVertexName),
        targetVertexExists = vertexMap.hasOwnProperty(targetVertexName);

    if (!sourceVertexExists) {
      var _sourceVertex = Vertex.fromVertexName(sourceVertexName);

      vertexMap[sourceVertexName] = _sourceVertex;
    }

    if (!targetVertexExists) {
      var _targetVertex = Vertex.fromVertexName(targetVertexName);

      vertexMap[targetVertexName] = _targetVertex;
    }

    var sourceVertex = vertexMap[sourceVertexName],
        targetVertex = vertexMap[targetVertexName],
        incomingEdge = edge,
        ///
    outgoingEdge = edge; ///

    sourceVertex.addOutgoingEdge(outgoingEdge);

    targetVertex.addIncomingEdge(incomingEdge);
  });

  return vertexMap;
}

function vertexMapFromVertexLiterals(vertexLiterals) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = first(vertexLiteral),
        vertexName = firstVertexLiteralElement,
        ///
    vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }

    var secondVertexLiteralElement = second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (!ancestorVertexExists) {
        var ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;
      }
    });
  });

  return vertexMap;
}

function edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap) {
  var edges = [];

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = first(vertexLiteral),
        secondVertexLiteralElement = second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var sourceVertexName = ancestorVertexName,
          ///
      targetVertexName = vertexName,
          ///
      sourceVertex = vertexMap[sourceVertexName],
          targetVertex = vertexMap[targetVertexName],
          edge = new Edge(sourceVertexName, targetVertexName),
          incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      edges.push(edge);

      sourceVertex.addOutgoingEdge(outgoingEdge);

      targetVertex.addIncomingEdge(incomingEdge);
    });
  });

  return edges;
}

function topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges) {
  var topologicallyOrderedVertexNames = [],
      startingVertexNames = startingVertexNamesFromVertexMap(vertexMap),
      removedEdges = [];

  var startingVertexNamesLength = startingVertexNames.length;

  var _loop = function _loop() {
    var startingVertexName = startingVertexNames.pop(),
        topologicallyOrderedVertexName = startingVertexName; ///

    topologicallyOrderedVertexNames.push(topologicallyOrderedVertexName);

    backwardsForEach(edges, function (edge, index) {
      var sourceVertexName = edge.getSourceVertexName(),
          edgeStarting = sourceVertexName === startingVertexName; ///

      if (edgeStarting) {
        edges.splice(index, 1);

        var targetVertexName = edge.getTargetVertexName(),
            targetVertex = vertexMap[targetVertexName],
            incomingEdge = edge,
            ///
        removedEdge = edge; ///

        targetVertex.removeIncomingEdge(incomingEdge);

        removedEdges.push(removedEdge);

        var targetVertexStarting = targetVertex.isStarting();

        if (targetVertexStarting) {
          var _startingVertexName = targetVertexName; ///

          startingVertexNames.push(_startingVertexName);
        }
      }
    });

    startingVertexNamesLength = startingVertexNames.length;
  };

  while (startingVertexNamesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength === 0) {
    removedEdges.forEach(function (removedEdge) {
      var targetVertexName = removedEdge.getTargetVertexName(),
          targetVertex = vertexMap[targetVertexName],
          incomingEdge = removedEdge; ///

      targetVertex.addIncomingEdge(incomingEdge);
    });
  }

  var topologicallySortedVertices = topologicallyOrderedVertexNames.map(function (topologicallyOrderedVertexName) {
    var topologicallyOrderedVertex = vertexMap[topologicallyOrderedVertexName];

    return topologicallyOrderedVertex;
  });

  return topologicallySortedVertices;
}

function startingVertexNamesFromVertexMap(vertexMap) {
  var vertexNames = Object.keys(vertexMap),
      startingVertexNames = vertexNames.reduce(function (startingVertexNames, vertexName) {
    var vertex = vertexMap[vertexName],
        vertexStarting = vertex.isStarting();

    if (vertexStarting) {
      var _startingVertexName2 = vertexName; ///

      startingVertexNames.push(_startingVertexName2);
    }

    return startingVertexNames;
  }, []);

  return startingVertexNames;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJuZWNlc3NhcnkiLCJyZXF1aXJlIiwiRWRnZSIsIlZlcnRleCIsIlJlbWFpbmluZ0VkZ2VzIiwiYXJyYXlVdGlsaXRpZXMiLCJmaXJzdCIsInNlY29uZCIsImJhY2t3YXJkc0ZvckVhY2giLCJHcmFwaCIsInRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMiLCJyZW1haW5pbmdFZGdlcyIsImFyZUN5Y2xlc1ByZXNlbnQiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRleE1hcCIsInZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyIsImVkZ2VzIiwiZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzRnJvbVZlcnRleE1hcEFuZEVkZ2VzIiwiZ3JhcGgiLCJ2ZXJ0ZXhOYW1lcyIsInNsaWNlIiwidmVydGV4TWFwRnJvbVZlcnRleE5hbWVzQW5kRWRnZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwiZm9yRWFjaCIsInZlcnRleE5hbWUiLCJ2ZXJ0ZXhFeGlzdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInZlcnRleCIsImZyb21WZXJ0ZXhOYW1lIiwiZWRnZSIsInNvdXJjZVZlcnRleE5hbWUiLCJnZXRTb3VyY2VWZXJ0ZXhOYW1lIiwidGFyZ2V0VmVydGV4TmFtZSIsImdldFRhcmdldFZlcnRleE5hbWUiLCJzb3VyY2VWZXJ0ZXhFeGlzdHMiLCJ0YXJnZXRWZXJ0ZXhFeGlzdHMiLCJzb3VyY2VWZXJ0ZXgiLCJ0YXJnZXRWZXJ0ZXgiLCJpbmNvbWluZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJhZGRPdXRnb2luZ0VkZ2UiLCJhZGRJbmNvbWluZ0VkZ2UiLCJ2ZXJ0ZXhMaXRlcmFsIiwiZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCIsInNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50IiwiYW5jZXN0b3JWZXJ0ZXhOYW1lcyIsImFuY2VzdG9yVmVydGV4TmFtZSIsImFuY2VzdG9yVmVydGV4RXhpc3RzIiwiYW5jZXN0b3JWZXJ0ZXgiLCJwdXNoIiwidG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXhOYW1lcyIsInN0YXJ0aW5nVmVydGV4TmFtZXMiLCJzdGFydGluZ1ZlcnRleE5hbWVzRnJvbVZlcnRleE1hcCIsInJlbW92ZWRFZGdlcyIsInN0YXJ0aW5nVmVydGV4TmFtZXNMZW5ndGgiLCJsZW5ndGgiLCJzdGFydGluZ1ZlcnRleE5hbWUiLCJwb3AiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWUiLCJpbmRleCIsImVkZ2VTdGFydGluZyIsInNwbGljZSIsInJlbW92ZWRFZGdlIiwicmVtb3ZlSW5jb21pbmdFZGdlIiwidGFyZ2V0VmVydGV4U3RhcnRpbmciLCJpc1N0YXJ0aW5nIiwiZWRnZXNMZW5ndGgiLCJ0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMiLCJtYXAiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleCIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJ2ZXJ0ZXhTdGFydGluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBLElBQU1BLFlBQVlDLFFBQVEsV0FBUixDQUFsQjs7QUFFQSxJQUFNQyxPQUFPRCxRQUFRLGNBQVIsQ0FBYjtBQUFBLElBQ01FLFNBQVNGLFFBQVEsZ0JBQVIsQ0FEZjtBQUFBLElBRU1HLGlCQUFpQkgsUUFBUSx3QkFBUixDQUZ2Qjs7QUFJTSxJQUFFSSxjQUFGLEdBQXFCTCxTQUFyQixDQUFFSyxjQUFGO0FBQUEsSUFDRUMsS0FERixHQUNzQ0QsY0FEdEMsQ0FDRUMsS0FERjtBQUFBLElBQ1NDLE1BRFQsR0FDc0NGLGNBRHRDLENBQ1NFLE1BRFQ7QUFBQSxJQUNpQkMsZ0JBRGpCLEdBQ3NDSCxjQUR0QyxDQUNpQkcsZ0JBRGpCOztJQUdBQyxLO0FBQ0osaUJBQWFDLDRCQUFiLEVBQTJDQyxjQUEzQyxFQUEyRDtBQUFBOztBQUN6RCxTQUFLRCw0QkFBTCxHQUFvQ0EsNEJBQXBDO0FBQ0EsU0FBS0MsY0FBTCxH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Q0QsR0FKbUMsQ0FBcEM7O0FBTUEsU0FBT0YsMkJBQVA7QUFDRDs7QUFFRCxTQUFTZixnQ0FBVCxDQUEwQ3hDLFNBQTFDLEVBQXFEO0FBQ25ELE1BQU1NLGNBQWNvRCxPQUFPQyxJQUFQLENBQVkzRCxTQUFaLENBQXBCO0FBQUEsTUFDTXVDLHNCQUFzQmpDLFlBQVlzRCxNQUFaLENBQW1CLFVBQVNyQixtQkFBVCxFQUE4QjNCLFVBQTlCLEVBQTBDO0FBQ2pGLFFBQU1HLFNBQVNmLFVBQVVZLFVBQVYsQ0FBZjtBQUFBLFFBQ01pRCxpQkFBaUI5QyxPQUFPc0MsVUFBUCxFQUR2Qjs7QUFHQSxRQUFJUSxjQUFKLEVBQW9CO0FBQ2xCLFVBQU1qQix1QkFBcUJoQyxVQUEzQixDQURrQixDQUNzQjs7QUFFeEMyQiwwQkFBb0JGLElBQXBCLENBQXlCTyxvQkFBekI7QUFDRDs7QUFFRCxXQUFPTCxtQkFBUDtBQUNELEdBWHFCLEVBV25CLEVBWG1CLENBRDVCOztBQWNBLFNBQU9BLG1CQUFQO0FBQ0QiLCJmaWxlIjoiZ3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5lY2Vzc2FyeSA9IHJlcXVpcmUoJ25lY2Vzc2FyeScpO1xuXG5jb25zdCBFZGdlID0gcmVxdWlyZSgnLi9ncmFwaC9lZGdlJyksXG4gICAgICBWZXJ0ZXggPSByZXF1aXJlKCcuL2dyYXBoL3ZlcnRleCcpLFxuICAgICAgUmVtYWluaW5nRWRnZXMgPSByZXF1aXJlKCcuL2dyYXBoL3JlbWFpbmluZ0VkZ2VzJyk7XG5cbmNvbnN0IHsgYXJyYXlVdGlsaXRpZXMgfSA9IG5lY2Vzc2FyeSxcbiAgICAgIHsgZmlyc3QsIHNlY29uZCwgYmFja3dhcmRzRm9yRWFjaCB9ID0gYXJyYXlVdGlsaXRpZXM7XG5cbmNsYXNzIEdyYXBoIHtcbiAgY29uc3RydWN0b3IgKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gICAgdGhpcy50b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzID0gdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcztcbiAgICB0aGlzLnJlbWFpbmluZ0VkZ2VzID0gcmVtYWluaW5nRWRnZXM7XG4gIH1cblxuICBnZXRUb3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzKCkge1xuICAgIHJldHVybiB0aGlzLnRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXM7XG4gIH1cblxuICBnZXRSZW1haW5pbmdFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmdFZGdlcztcbiAgfVxuXG4gIGFyZUN5Y2xlc1ByZXNlbnQoKSB7IHJldHVybiB0aGlzLnJlbWFpbmluZ0VkZ2VzLmFyZUN5Y2xlc1ByZXNlbnQoKTsgfVxuXG4gIHN0YXRpYyBmcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhNYXAgPSB2ZXJ0ZXhNYXBGcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpLFxuICAgICAgICAgIGVkZ2VzID0gZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAodmVydGV4TGl0ZXJhbHMsIHZlcnRleE1hcCksXG4gICAgICAgICAgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcyksXG4gICAgICAgICAgcmVtYWluaW5nRWRnZXMgPSBuZXcgUmVtYWluaW5nRWRnZXMoZWRnZXMpLFxuICAgICAgICAgIGdyYXBoID0gbmV3IEdyYXBoKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMsIHJlbWFpbmluZ0VkZ2VzKTtcblxuICAgIHJldHVybiBncmFwaDtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVydGV4TmFtZXNBbmRFZGdlcyh2ZXJ0ZXhOYW1lcywgZWRnZXMpIHtcbiAgICBlZGdlcyA9IGVkZ2VzLnNsaWNlKCk7ICAvLy9cblxuICAgIGNvbnN0IHZlcnRleE1hcCA9IHZlcnRleE1hcEZyb21WZXJ0ZXhOYW1lc0FuZEVkZ2VzKHZlcnRleE5hbWVzLCBlZGdlcyksXG4gICAgICAgICAgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcyksXG4gICAgICAgICAgcmVtYWluaW5nRWRnZXMgPSBuZXcgUmVtYWluaW5nRWRnZXMoZWRnZXMpLFxuICAgICAgICAgIGdyYXBoID0gbmV3IEdyYXBoKHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXMsIHJlbWFpbmluZ0VkZ2VzKTtcblxuICAgIHJldHVybiBncmFwaDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoO1xuXG5mdW5jdGlvbiB2ZXJ0ZXhNYXBGcm9tVmVydGV4TmFtZXNBbmRFZGdlcyh2ZXJ0ZXhOYW1lcywgZWRnZXMpIHtcbiAgY29uc3QgdmVydGV4TWFwID0ge307XG5cbiAgdmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXhOYW1lKSB7XG4gICAgY29uc3QgdmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KHZlcnRleE5hbWUpO1xuXG4gICAgaWYgKCF2ZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIGNvbnN0IHZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZSh2ZXJ0ZXhOYW1lKTtcblxuICAgICAgdmVydGV4TWFwW3ZlcnRleE5hbWVdID0gdmVydGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKSB7XG4gICAgY29uc3Qgc291cmNlVmVydGV4TmFtZSA9IGVkZ2UuZ2V0U291cmNlVmVydGV4TmFtZSgpLFxuICAgICAgICAgIHRhcmdldFZlcnRleE5hbWUgPSBlZGdlLmdldFRhcmdldFZlcnRleE5hbWUoKSxcbiAgICAgICAgICBzb3VyY2VWZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkoc291cmNlVmVydGV4TmFtZSksXG4gICAgICAgICAgdGFyZ2V0VmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KHRhcmdldFZlcnRleE5hbWUpO1xuXG4gICAgaWYgKCFzb3VyY2VWZXJ0ZXhFeGlzdHMpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZShzb3VyY2VWZXJ0ZXhOYW1lKTtcblxuICAgICAgdmVydGV4TWFwW3NvdXJjZVZlcnRleE5hbWVdID0gc291cmNlVmVydGV4O1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0VmVydGV4RXhpc3RzKSB7XG4gICAgICBjb25zdCB0YXJnZXRWZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUodGFyZ2V0VmVydGV4TmFtZSk7XG5cbiAgICAgIHZlcnRleE1hcFt0YXJnZXRWZXJ0ZXhOYW1lXSA9IHRhcmdldFZlcnRleDtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VWZXJ0ZXggPSB2ZXJ0ZXhNYXBbc291cmNlVmVydGV4TmFtZV0sXG4gICAgICAgICAgdGFyZ2V0VmVydGV4ID0gdmVydGV4TWFwW3RhcmdldFZlcnRleE5hbWVdLFxuICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2UsICAvLy9cbiAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICBzb3VyY2VWZXJ0ZXguYWRkT3V0Z29pbmdFZGdlKG91dGdvaW5nRWRnZSk7XG5cbiAgICB0YXJnZXRWZXJ0ZXguYWRkSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJ0ZXhNYXA7XG59XG5cbmZ1bmN0aW9uIHZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscykge1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcblxuICB2ZXJ0ZXhMaXRlcmFscy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleExpdGVyYWwpIHtcbiAgICBjb25zdCBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50ID0gZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgdmVydGV4TmFtZSA9IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQsIC8vL1xuICAgICAgICAgIHZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhOYW1lKTtcblxuICAgIGlmICghdmVydGV4RXhpc3RzKSB7XG4gICAgICBjb25zdCB2ZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUodmVydGV4TmFtZSk7XG5cbiAgICAgIHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSA9IHZlcnRleDtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCA9IHNlY29uZCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBhbmNlc3RvclZlcnRleE5hbWVzID0gc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQ7IC8vL1xuXG4gICAgYW5jZXN0b3JWZXJ0ZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFuY2VzdG9yVmVydGV4TmFtZSkge1xuICAgICAgY29uc3QgYW5jZXN0b3JWZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkoYW5jZXN0b3JWZXJ0ZXhOYW1lKTtcblxuICAgICAgaWYgKCFhbmNlc3RvclZlcnRleEV4aXN0cykge1xuICAgICAgICBjb25zdCBhbmNlc3RvclZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZShhbmNlc3RvclZlcnRleE5hbWUpO1xuXG4gICAgICAgIHZlcnRleE1hcFthbmNlc3RvclZlcnRleE5hbWVdID0gYW5jZXN0b3JWZXJ0ZXg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB2ZXJ0ZXhNYXA7XG59XG5cbmZ1bmN0aW9uIGVkZ2VzRnJvbVZlcnRleExpdGVyYWxzQW5kVmVydGV4TWFwKHZlcnRleExpdGVyYWxzLCB2ZXJ0ZXhNYXApIHtcbiAgY29uc3QgZWRnZXMgPSBbXTtcblxuICB2ZXJ0ZXhMaXRlcmFscy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleExpdGVyYWwpIHtcbiAgICBjb25zdCBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50ID0gZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBzZWNvbmQodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgYW5jZXN0b3JWZXJ0ZXhOYW1lcyA9IHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOYW1lID0gZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudDsgLy8vXG5cbiAgICBhbmNlc3RvclZlcnRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24oYW5jZXN0b3JWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBzb3VyY2VWZXJ0ZXhOYW1lID0gYW5jZXN0b3JWZXJ0ZXhOYW1lLCAvLy9cbiAgICAgICAgICAgIHRhcmdldFZlcnRleE5hbWUgPSB2ZXJ0ZXhOYW1lLCAgLy8vXG4gICAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSB2ZXJ0ZXhNYXBbc291cmNlVmVydGV4TmFtZV0sXG4gICAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSB2ZXJ0ZXhNYXBbdGFyZ2V0VmVydGV4TmFtZV0sXG4gICAgICAgICAgICBlZGdlID0gbmV3IEVkZ2Uoc291cmNlVmVydGV4TmFtZSwgdGFyZ2V0VmVydGV4TmFtZSksXG4gICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSBlZGdlLCAgLy8vXG4gICAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG5cbiAgICAgIHNvdXJjZVZlcnRleC5hZGRPdXRnb2luZ0VkZ2Uob3V0Z29pbmdFZGdlKTtcblxuICAgICAgdGFyZ2V0VmVydGV4LmFkZEluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbmZ1bmN0aW9uIHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcykge1xuICBjb25zdCB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWVzID0gW10sXG4gICAgICAgIHN0YXJ0aW5nVmVydGV4TmFtZXMgPSBzdGFydGluZ1ZlcnRleE5hbWVzRnJvbVZlcnRleE1hcCh2ZXJ0ZXhNYXApLFxuICAgICAgICByZW1vdmVkRWRnZXMgPSBbXTtcblxuICBsZXQgc3RhcnRpbmdWZXJ0ZXhOYW1lc0xlbmd0aCA9IHN0YXJ0aW5nVmVydGV4TmFtZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydGluZ1ZlcnRleE5hbWVzTGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4TmFtZSA9IHN0YXJ0aW5nVmVydGV4TmFtZXMucG9wKCksXG4gICAgICAgICAgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXhOYW1lID0gc3RhcnRpbmdWZXJ0ZXhOYW1lOyAgLy8vXG5cbiAgICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWVzLnB1c2godG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXhOYW1lKTtcblxuICAgIGJhY2t3YXJkc0ZvckVhY2goZWRnZXMsIGZ1bmN0aW9uKGVkZ2UsIGluZGV4KSB7XG4gICAgICBjb25zdCBzb3VyY2VWZXJ0ZXhOYW1lID0gZWRnZS5nZXRTb3VyY2VWZXJ0ZXhOYW1lKCksXG4gICAgICAgICAgICBlZGdlU3RhcnRpbmcgPSAoc291cmNlVmVydGV4TmFtZSA9PT0gc3RhcnRpbmdWZXJ0ZXhOYW1lKTsgLy8vXG5cbiAgICAgIGlmIChlZGdlU3RhcnRpbmcpIHtcbiAgICAgICAgZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICBjb25zdCB0YXJnZXRWZXJ0ZXhOYW1lID0gZWRnZS5nZXRUYXJnZXRWZXJ0ZXhOYW1lKCksXG4gICAgICAgICAgICAgIHRhcmdldFZlcnRleCA9IHZlcnRleE1hcFt0YXJnZXRWZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgICAgaW5jb21pbmdFZGdlID0gZWRnZSwgLy8vXG4gICAgICAgICAgICAgIHJlbW92ZWRFZGdlID0gZWRnZTsgIC8vL1xuXG4gICAgICAgIHRhcmdldFZlcnRleC5yZW1vdmVJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcblxuICAgICAgICByZW1vdmVkRWRnZXMucHVzaChyZW1vdmVkRWRnZSk7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0VmVydGV4U3RhcnRpbmcgPSB0YXJnZXRWZXJ0ZXguaXNTdGFydGluZygpO1xuXG4gICAgICAgIGlmICh0YXJnZXRWZXJ0ZXhTdGFydGluZykge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4TmFtZSA9IHRhcmdldFZlcnRleE5hbWU7ICAvLy9cblxuICAgICAgICAgIHN0YXJ0aW5nVmVydGV4TmFtZXMucHVzaChzdGFydGluZ1ZlcnRleE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzdGFydGluZ1ZlcnRleE5hbWVzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0ZXhOYW1lcy5sZW5ndGg7XG4gIH1cblxuICBjb25zdCBlZGdlc0xlbmd0aCA9IGVkZ2VzLmxlbmd0aDtcblxuICBpZiAoZWRnZXNMZW5ndGggPT09IDApIHtcbiAgICByZW1vdmVkRWRnZXMuZm9yRWFjaChmdW5jdGlvbihyZW1vdmVkRWRnZSkge1xuICAgICAgY29uc3QgdGFyZ2V0VmVydGV4TmFtZSA9IHJlbW92ZWRFZGdlLmdldFRhcmdldFZlcnRleE5hbWUoKSxcbiAgICAgICAgICAgIHRhcmdldFZlcnRleCA9IHZlcnRleE1hcFt0YXJnZXRWZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgIGluY29taW5nRWRnZSA9IHJlbW92ZWRFZGdlOyAvLy9cbiAgICAgIFxuICAgICAgdGFyZ2V0VmVydGV4LmFkZEluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuICAgIH0pXG4gIH1cblxuICBjb25zdCB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMgPSB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWVzLm1hcChmdW5jdGlvbih0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWUpIHtcbiAgICBjb25zdCB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleCA9IHZlcnRleE1hcFt0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleE5hbWVdO1xuXG4gICAgcmV0dXJuIHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGV4O1xuICB9KTtcblxuICByZXR1cm4gdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzO1xufVxuXG5mdW5jdGlvbiBzdGFydGluZ1ZlcnRleE5hbWVzRnJvbVZlcnRleE1hcCh2ZXJ0ZXhNYXApIHtcbiAgY29uc3QgdmVydGV4TmFtZXMgPSBPYmplY3Qua2V5cyh2ZXJ0ZXhNYXApLFxuICAgICAgICBzdGFydGluZ1ZlcnRleE5hbWVzID0gdmVydGV4TmFtZXMucmVkdWNlKGZ1bmN0aW9uKHN0YXJ0aW5nVmVydGV4TmFtZXMsIHZlcnRleE5hbWUpIHtcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0sXG4gICAgICAgICAgICAgICAgdmVydGV4U3RhcnRpbmcgPSB2ZXJ0ZXguaXNTdGFydGluZygpO1xuXG4gICAgICAgICAgaWYgKHZlcnRleFN0YXJ0aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ1ZlcnRleE5hbWUgPSB2ZXJ0ZXhOYW1lOyAgLy8vXG5cbiAgICAgICAgICAgIHN0YXJ0aW5nVmVydGV4TmFtZXMucHVzaChzdGFydGluZ1ZlcnRleE5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdGFydGluZ1ZlcnRleE5hbWVzXG4gICAgICAgIH0sIFtdKTtcblxuICByZXR1cm4gc3RhcnRpbmdWZXJ0ZXhOYW1lcztcbn1cbiJdfQ==