'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(topologicallySortedVertices, remainingEdges) {
    _classCallCheck(this, Graph);

    this.topologicallySortedVertices = topologicallySortedVertices;
    this.remainingEdges = remainingEdges;
  }

  _createClass(Graph, [{
    key: 'getTopologicallySortedVertices',
    value: function getTopologicallySortedVertices() {
      return this.topologicallySortedVertices;
    }
  }, {
    key: 'getRemainingEdges',
    value: function getRemainingEdges() {
      return this.remainingEdges;
    }
  }, {
    key: 'areCyclesPresent',
    value: function areCyclesPresent() {
      var remainingEdgesLength = this.remainingEdges.length,
          cyclesPresent = remainingEdgesLength !== 0;

      return cyclesPresent;
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertexMap = vertexMapFromVertexLiterals(vertexLiterals),
          edges = edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap),
          topologicallySortedVertices = topologicallySortedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = edges,
          ///
      graph = new Graph(topologicallySortedVertices, remainingEdges);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function vertexMapFromVertexLiterals(vertexLiterals) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        vertexName = firstVertexLiteralElement,
        ///
    vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }

    var secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (!ancestorVertexExists) {
        var ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;
      }
    });
  });

  return vertexMap;
}

function edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap) {
  var edges = [];

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement,
        ///
    vertex = vertexMap[vertexName];

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertex = vertexMap[ancestorVertexName],
          sourceVertex = ancestorVertex,
          ///
      targetVertex = vertex,
          ///
      edge = new Edge(sourceVertex, targetVertex),
          incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      edges.push(edge);

      vertex.addIncomingEdge(incomingEdge);

      ancestorVertex.addOutgoingEdge(outgoingEdge);
    });
  });

  return edges;
}

function topologicallySortedVerticesFromVertexMapAndEdges(vertexMap, edges) {
  var topologicallySortedVertices = [];

  var startingVertices = startingVerticesFromVertexMap(vertexMap),
      removedEdges = [];

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        topologicallySortedVertex = startingVertex; ///

    topologicallySortedVertices.push(topologicallySortedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var sourceVertex = edge.getSourceVertex(),
          edgeStarting = sourceVertex === startingVertex; ///

      if (edgeStarting) {
        var targetVertex = edge.getTargetVertex(),
            incomingEdge = edge,
            ///
        removedEdge = edge; ///

        targetVertex.removeIncomingEdge(incomingEdge);

        removedEdges.push(removedEdge);

        var targetVertexStarting = targetVertex.isStarting();

        if (targetVertexStarting) {
          var _startingVertex = targetVertex; ///

          startingVertices.push(_startingVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength === 0) {
    removedEdges.forEach(function (removedEdge) {
      var sourceVertex = removedEdge.getSourceVertex(),
          targetVertex = removedEdge.getTargetVertex(),
          outgoingEdge = removedEdge,
          ///
      incomingEdge = removedEdge; ///

      sourceVertex.addOutgoingEdge(outgoingEdge);
      targetVertex.addIncomingEdge(incomingEdge);
    });
  }

  return topologicallySortedVertices;
}

function startingVerticesFromVertexMap(vertexMap) {
  var vertexNames = Object.keys(vertexMap),
      startingVertices = vertexNames.reduce(function (startingVertices, vertexName) {
    var vertex = vertexMap[vertexName],
        vertexStarting = vertex.isStarting();

    if (vertexStarting) {
      var _startingVertex2 = vertex; ///

      startingVertices.push(_startingVertex2);
    }

    return startingVertices;
  }, []);

  return startingVertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzIiwicmVtYWluaW5nRWRnZXMiLCJyZW1haW5pbmdFZGdlc0xlbmd0aCIsImxlbmd0aCIsImN5Y2xlc1ByZXNlbnQiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRleE1hcCIsInZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyIsImVkZ2VzIiwiZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAiLCJ0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXMiLCJncmFwaCIsIm1vZHVsZSIsImV4cG9ydHMiLCJmb3JFYWNoIiwidmVydGV4TGl0ZXJhbCIsImZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJmaXJzdCIsInZlcnRleE5hbWUiLCJ2ZXJ0ZXhFeGlzdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInZlcnRleCIsImZyb21WZXJ0ZXhOYW1lIiwic2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJzZWNvbmQiLCJhbmNlc3RvclZlcnRleE5hbWVzIiwiYW5jZXN0b3JWZXJ0ZXhOYW1lIiwiYW5jZXN0b3JWZXJ0ZXhFeGlzdHMiLCJhbmNlc3RvclZlcnRleCIsInNvdXJjZVZlcnRleCIsInRhcmdldFZlcnRleCIsImVkZ2UiLCJpbmNvbWluZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJwdXNoIiwiYWRkSW5jb21pbmdFZGdlIiwiYWRkT3V0Z29pbmdFZGdlIiwic3RhcnRpbmdWZXJ0aWNlcyIsInN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwIiwicmVtb3ZlZEVkZ2VzIiwic3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCIsInN0YXJ0aW5nVmVydGV4IiwicG9wIiwidG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRleCIsImJhY2t3YXJkc0ZvckVhY2giLCJpbmRleCIsImdldFNvdXJjZVZlcnRleCIsImVkZ2VTdGFydGluZyIsImdldFRhcmdldFZlcnRleCIsInJlbW92ZWRFZGdlIiwicmVtb3ZlSW5jb21pbmdFZGdlIiwidGFyZ2V0VmVydGV4U3RhcnRpbmciLCJpc1N0YXJ0aW5nIiwiZWRnZXNMZW5ndGgiLCJ2ZXJ0ZXhOYW1lcyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJ2ZXJ0ZXhTdGFydGluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBLElBQU1BLE9BQU9DLFFBQVEsY0FBUixDQUFiO0FBQUEsSUFDTUMsU0FBU0QsUUFBUSxnQkFBUixDQURmO0FBQUEsSUFFTUUsWUFBWUYsUUFBUSxjQUFSLENBRmxCOztJQUlNRyxLO0FBQ0osaUJBQWFDLDJCQUFiLEVBQTBDQyxjQUExQyxFQUEwRDtBQUFBOztBQUN4RCxTQUFLRCwyQkFBTCxHQUFtQ0EsMkJBQW5DO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQkEsY0FBdEI7QUFDRDs7OztxREFFZ0M7QUFDL0IsYUFBTyxLQUFLRCwyQkFBWjtBQUNEOzs7d0NBRW1CO0FBQ2xCLGFBQU8sS0FBS0MsY0FBWjtBQUNEOzs7dUNBRWtCO0FBQ2pCLFVBQU1DLHVCQUF1QixLQUFLRCxjQUFMLENBQW9CRSxNQUFqRDtBQUFBLFVBQ01DLGdCQUFpQkYseUJBQXlCLENBRGhEOztBQUdBLGFBQU9FLGFBQVA7QUFDRDs7O3VDQUV5QkMsYyxFQUFnQjtBQUN4QyxVQUFNQyxZQUFZQyw0QkFBNEJGLGNBQTVCLENBQWxCO0FBQUEsVUFDTUcsUUFBUUMsb0NBQW9DSixjQUFwQyxFQUFvREMsU0FBcEQsQ0FEZDtBQUFBLFVBRU1OLDhCQUE4QlUsaURBQWlESixTQUFqRCxFQUE0REUsS0FBNUQsQ0FGcEM7QUFBQSxVQUdNUCxpQkFBaUJPLEtBSHZCO0FBQUEsVUFHOEI7QUFDeEJHLGNBQVEsSUFBSVosS0FBSixDQUFVQywyQkFBVixFQUF1Q0MsY0FBdkMsQ0FKZDs7QUFNQSxhQUFPVSxLQUFQO0FBQ0Q7Ozs7OztBQUdIQyxP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QUFULENBQXVDaEMsU0FBdkMsRUFBa0Q7QUFDaEQsTUFBTWdELGNBQWNDLE9BQU9DLElBQVAsQ0FBWWxELFNBQVosQ0FBcEI7QUFBQSxNQUNNK0IsbUJBQW1CaUIsWUFBWUcsTUFBWixDQUFtQixVQUFTcEIsZ0JBQVQsRUFBMkJuQixVQUEzQixFQUF1QztBQUMzRSxRQUFNRyxTQUFTZixVQUFVWSxVQUFWLENBQWY7QUFBQSxRQUNNd0MsaUJBQWlCckMsT0FBTytCLFVBQVAsRUFEdkI7O0FBR0EsUUFBSU0sY0FBSixFQUFvQjtBQUNsQixVQUFNakIsbUJBQWlCcEIsTUFBdkIsQ0FEa0IsQ0FDYzs7QUFFaENnQix1QkFBaUJILElBQWpCLENBQXNCTyxnQkFBdEI7QUFDRDs7QUFFRCxXQUFPSixnQkFBUDtBQUNELEdBWGtCLEVBV2hCLEVBWGdCLENBRHpCOztBQWNBLFNBQU9BLGdCQUFQO0FBQ0QiLCJmaWxlIjoiZ3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVkZ2UgPSByZXF1aXJlKCcuL2dyYXBoL2VkZ2UnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vZ3JhcGgvdmVydGV4JyksXG4gICAgICBhcnJheVV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYXJyYXknKTtcblxuY2xhc3MgR3JhcGgge1xuICBjb25zdHJ1Y3RvciAodG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzLCByZW1haW5pbmdFZGdlcykge1xuICAgIHRoaXMudG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzID0gdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzO1xuICAgIHRoaXMucmVtYWluaW5nRWRnZXMgPSByZW1haW5pbmdFZGdlcztcbiAgfVxuXG4gIGdldFRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXM7XG4gIH1cblxuICBnZXRSZW1haW5pbmdFZGdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmdFZGdlcztcbiAgfVxuICBcbiAgYXJlQ3ljbGVzUHJlc2VudCgpIHtcbiAgICBjb25zdCByZW1haW5pbmdFZGdlc0xlbmd0aCA9IHRoaXMucmVtYWluaW5nRWRnZXMubGVuZ3RoLFxuICAgICAgICAgIGN5Y2xlc1ByZXNlbnQgPSAocmVtYWluaW5nRWRnZXNMZW5ndGggIT09IDApO1xuICAgIFxuICAgIHJldHVybiBjeWNsZXNQcmVzZW50O1xuICB9XG5cbiAgc3RhdGljIGZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscykge1xuICAgIGNvbnN0IHZlcnRleE1hcCA9IHZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscyksXG4gICAgICAgICAgZWRnZXMgPSBlZGdlc0Zyb21WZXJ0ZXhMaXRlcmFsc0FuZFZlcnRleE1hcCh2ZXJ0ZXhMaXRlcmFscywgdmVydGV4TWFwKSxcbiAgICAgICAgICB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXMgPSB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcyksXG4gICAgICAgICAgcmVtYWluaW5nRWRnZXMgPSBlZGdlcywgLy8vXG4gICAgICAgICAgZ3JhcGggPSBuZXcgR3JhcGgodG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzLCByZW1haW5pbmdFZGdlcyk7XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxuZnVuY3Rpb24gdmVydGV4TWFwRnJvbVZlcnRleExpdGVyYWxzKHZlcnRleExpdGVyYWxzKSB7XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgdmVydGV4TmFtZSA9IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQsIC8vL1xuICAgICAgICAgIHZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eSh2ZXJ0ZXhOYW1lKTtcblxuICAgIGlmICghdmVydGV4RXhpc3RzKSB7XG4gICAgICBjb25zdCB2ZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUodmVydGV4TmFtZSk7XG5cbiAgICAgIHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSA9IHZlcnRleDtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCA9IGFycmF5VXRpbC5zZWNvbmQodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgYW5jZXN0b3JWZXJ0ZXhOYW1lcyA9IHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50OyAvLy9cblxuICAgIGFuY2VzdG9yVmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbihhbmNlc3RvclZlcnRleE5hbWUpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KGFuY2VzdG9yVmVydGV4TmFtZSk7XG5cbiAgICAgIGlmICghYW5jZXN0b3JWZXJ0ZXhFeGlzdHMpIHtcbiAgICAgICAgY29uc3QgYW5jZXN0b3JWZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUoYW5jZXN0b3JWZXJ0ZXhOYW1lKTtcblxuICAgICAgICB2ZXJ0ZXhNYXBbYW5jZXN0b3JWZXJ0ZXhOYW1lXSA9IGFuY2VzdG9yVmVydGV4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdmVydGV4TWFwO1xufVxuXG5mdW5jdGlvbiBlZGdlc0Zyb21WZXJ0ZXhMaXRlcmFsc0FuZFZlcnRleE1hcCh2ZXJ0ZXhMaXRlcmFscywgdmVydGV4TWFwKSB7XG4gIGNvbnN0IGVkZ2VzID0gW107XG5cbiAgdmVydGV4TGl0ZXJhbHMuZm9yRWFjaChmdW5jdGlvbih2ZXJ0ZXhMaXRlcmFsKSB7XG4gICAgY29uc3QgZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCA9IGFycmF5VXRpbC5maXJzdCh2ZXJ0ZXhMaXRlcmFsKSxcbiAgICAgICAgICBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCA9IGFycmF5VXRpbC5zZWNvbmQodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgYW5jZXN0b3JWZXJ0ZXhOYW1lcyA9IHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOYW1lID0gZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4ID0gdmVydGV4TWFwW3ZlcnRleE5hbWVdO1xuXG4gICAgYW5jZXN0b3JWZXJ0ZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFuY2VzdG9yVmVydGV4TmFtZSkge1xuICAgICAgY29uc3QgYW5jZXN0b3JWZXJ0ZXggPSB2ZXJ0ZXhNYXBbYW5jZXN0b3JWZXJ0ZXhOYW1lXSxcbiAgICAgICAgICAgIHNvdXJjZVZlcnRleCA9IGFuY2VzdG9yVmVydGV4LCAvLy9cbiAgICAgICAgICAgIHRhcmdldFZlcnRleCA9IHZlcnRleCwgIC8vL1xuICAgICAgICAgICAgZWRnZSA9IG5ldyBFZGdlKHNvdXJjZVZlcnRleCwgdGFyZ2V0VmVydGV4KSxcbiAgICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2UsICAvLy9cbiAgICAgICAgICAgIG91dGdvaW5nRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgICAgZWRnZXMucHVzaChlZGdlKTtcblxuICAgICAgdmVydGV4LmFkZEluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuXG4gICAgICBhbmNlc3RvclZlcnRleC5hZGRPdXRnb2luZ0VkZ2Uob3V0Z29pbmdFZGdlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG5mdW5jdGlvbiB0b3BvbG9naWNhbGx5U29ydGVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcykge1xuICBsZXQgdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzID0gW107XG5cbiAgY29uc3Qgc3RhcnRpbmdWZXJ0aWNlcyA9IHN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwKHZlcnRleE1hcCksXG4gICAgICAgIHJlbW92ZWRFZGdlcyA9IFtdO1xuXG4gIGxldCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSBzdGFydGluZ1ZlcnRpY2VzLnBvcCgpLFxuICAgICAgICAgIHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0ZXggPSBzdGFydGluZ1ZlcnRleDsgIC8vL1xuXG4gICAgdG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRpY2VzLnB1c2godG9wb2xvZ2ljYWxseVNvcnRlZFZlcnRleCk7XG5cbiAgICBhcnJheVV0aWwuYmFja3dhcmRzRm9yRWFjaChlZGdlcywgZnVuY3Rpb24oZWRnZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IGVkZ2UuZ2V0U291cmNlVmVydGV4KCksXG4gICAgICAgICAgICBlZGdlU3RhcnRpbmcgPSAoc291cmNlVmVydGV4ID09PSBzdGFydGluZ1ZlcnRleCk7IC8vL1xuXG4gICAgICBpZiAoZWRnZVN0YXJ0aW5nKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFZlcnRleCA9IGVkZ2UuZ2V0VGFyZ2V0VmVydGV4KCksXG4gICAgICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2UsIC8vL1xuICAgICAgICAgICAgICByZW1vdmVkRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgICAgICB0YXJnZXRWZXJ0ZXgucmVtb3ZlSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG5cbiAgICAgICAgcmVtb3ZlZEVkZ2VzLnB1c2gocmVtb3ZlZEVkZ2UpO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFZlcnRleFN0YXJ0aW5nID0gdGFyZ2V0VmVydGV4LmlzU3RhcnRpbmcoKTtcblxuICAgICAgICBpZiAodGFyZ2V0VmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICBjb25zdCBzdGFydGluZ1ZlcnRleCA9IHRhcmdldFZlcnRleDsgIC8vL1xuXG4gICAgICAgICAgc3RhcnRpbmdWZXJ0aWNlcy5wdXNoKHN0YXJ0aW5nVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCA9IHN0YXJ0aW5nVmVydGljZXMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgZWRnZXNMZW5ndGggPSBlZGdlcy5sZW5ndGg7XG5cbiAgaWYgKGVkZ2VzTGVuZ3RoID09PSAwKSB7XG4gICAgcmVtb3ZlZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24ocmVtb3ZlZEVkZ2UpIHtcbiAgICAgIGNvbnN0IHNvdXJjZVZlcnRleCA9IHJlbW92ZWRFZGdlLmdldFNvdXJjZVZlcnRleCgpLFxuICAgICAgICAgICAgdGFyZ2V0VmVydGV4ID0gcmVtb3ZlZEVkZ2UuZ2V0VGFyZ2V0VmVydGV4KCksXG4gICAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSByZW1vdmVkRWRnZSwgLy8vXG4gICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSByZW1vdmVkRWRnZTsgLy8vXG4gICAgICBcbiAgICAgIHNvdXJjZVZlcnRleC5hZGRPdXRnb2luZ0VkZ2Uob3V0Z29pbmdFZGdlKTtcbiAgICAgIHRhcmdldFZlcnRleC5hZGRJbmNvbWluZ0VkZ2UoaW5jb21pbmdFZGdlKTtcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHRvcG9sb2dpY2FsbHlTb3J0ZWRWZXJ0aWNlcztcbn1cblxuZnVuY3Rpb24gc3RhcnRpbmdWZXJ0aWNlc0Zyb21WZXJ0ZXhNYXAodmVydGV4TWFwKSB7XG4gIGNvbnN0IHZlcnRleE5hbWVzID0gT2JqZWN0LmtleXModmVydGV4TWFwKSxcbiAgICAgICAgc3RhcnRpbmdWZXJ0aWNlcyA9IHZlcnRleE5hbWVzLnJlZHVjZShmdW5jdGlvbihzdGFydGluZ1ZlcnRpY2VzLCB2ZXJ0ZXhOYW1lKSB7XG4gICAgICAgICAgY29uc3QgdmVydGV4ID0gdmVydGV4TWFwW3ZlcnRleE5hbWVdLFxuICAgICAgICAgICAgICAgIHZlcnRleFN0YXJ0aW5nID0gdmVydGV4LmlzU3RhcnRpbmcoKTtcblxuICAgICAgICAgIGlmICh2ZXJ0ZXhTdGFydGluZykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSB2ZXJ0ZXg7ICAvLy9cblxuICAgICAgICAgICAgc3RhcnRpbmdWZXJ0aWNlcy5wdXNoKHN0YXJ0aW5nVmVydGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhcnRpbmdWZXJ0aWNlc1xuICAgICAgICB9LCBbXSk7XG5cbiAgcmV0dXJuIHN0YXJ0aW5nVmVydGljZXM7XG59XG4iXX0=