'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(sortedVertices) {
    _classCallCheck(this, Graph);

    this.sortedVertices = sortedVertices;
  }

  _createClass(Graph, [{
    key: 'getSortedVertices',
    value: function getSortedVertices() {
      return this.sortedVertices;
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertices = [],
          edges = [];

      verticesAndEdgesFromVertexLiterals(vertexLiterals, vertices, edges);

      var sortedVertices = sortedVerticesFromVerticesAndEdges(vertices, edges);

      addAncestorVerticesToSortedVertices(sortedVertices);

      var graph = new Graph(sortedVertices);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function verticesAndEdgesFromVertexLiterals(vertexLiterals, vertices, edges) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        descendantVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement; ///

    var vertex = void 0;

    var vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (vertexExists) {
      vertex = vertexMap[vertexName];
    } else {
      vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;

      vertices.push(vertex);
    }

    descendantVertexNames.forEach(function (descendantVertexName) {
      var descendantVertex = void 0;

      var descendantVertexExists = vertexMap.hasOwnProperty(descendantVertexName);

      if (descendantVertexExists) {
        descendantVertex = vertexMap[descendantVertexName];
      } else {
        descendantVertex = Vertex.fromVertexName(descendantVertexName);

        vertexMap[descendantVertexName] = descendantVertex;

        vertices.push(descendantVertex);
      }

      var firstVertex = vertex,
          secondVertex = descendantVertex,
          edge = new Edge(firstVertex, secondVertex);

      edges.push(edge);

      var incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      descendantVertex.addIncomingEdge(incomingEdge);

      vertex.addOutgoingEdge(outgoingEdge);
    });
  });
}

function sortedVerticesFromVerticesAndEdges(vertices, edges) {
  var sortedVertices = [];

  var startingVertices = vertices.filter(function (vertex) {
    var vertexStarting = vertex.isStarting();

    return vertexStarting;
  });

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        sortedVertex = startingVertex; ///

    sortedVertices.push(sortedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var firstVertex = edge.getFirstVertex(),
          edgeStarting = firstVertex === startingVertex;

      if (edgeStarting) {
        edges.splice(index, 1);

        var lastVertex = edge.getLastVertex(),
            incomingEdge = edge; ///

        lastVertex.removeIncomingEdge(incomingEdge);

        var lastVertexStarting = lastVertex.isStarting();

        if (lastVertexStarting) {
          startingVertices.push(lastVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength > 0) {
    sortedVertices = null;
  }

  return sortedVertices;
}

function addAncestorVerticesToSortedVertices(sortedVertices) {
  if (sortedVertices !== null) {
    sortedVertices.forEach(function (sortedVertex) {
      sortedVertex.forEachOutgoingEdge(function (outgoingEdge) {
        var outgoingEdgeLastVertex = outgoingEdge.getLastVertex(),
            descendantVertex = outgoingEdgeLastVertex,
            ///
        ancestorVertex = sortedVertex,
            ///
        ancestorVertices = ancestorVertex.getAncestorVertices(); ///

        descendantVertex.addAncestorVertices(ancestorVertices);

        descendantVertex.addAncestorVertex(ancestorVertex);
      });
    });
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwic29ydGVkVmVydGljZXMiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRpY2VzIiwiZWRnZXMiLCJ2ZXJ0aWNlc0FuZEVkZ2VzRnJvbVZlcnRleExpdGVyYWxzIiwic29ydGVkVmVydGljZXNGcm9tVmVydGljZXNBbmRFZGdlcyIsImFkZEFuY2VzdG9yVmVydGljZXNUb1NvcnRlZFZlcnRpY2VzIiwiZ3JhcGgiLCJtb2R1bGUiLCJleHBvcnRzIiwidmVydGV4TWFwIiwiZm9yRWFjaCIsInZlcnRleExpdGVyYWwiLCJmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50IiwiZmlyc3QiLCJzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCIsInNlY29uZCIsImRlc2NlbmRhbnRWZXJ0ZXhOYW1lcyIsInZlcnRleE5hbWUiLCJ2ZXJ0ZXgiLCJ2ZXJ0ZXhFeGlzdHMiLCJoYXNPd25Qcm9wZXJ0eSIsImZyb21WZXJ0ZXhOYW1lIiwicHVzaCIsImRlc2NlbmRhbnRWZXJ0ZXhOYW1lIiwiZGVzY2VuZGFudFZlcnRleCIsImRlc2NlbmRhbnRWZXJ0ZXhFeGlzdHMiLCJmaXJzdFZlcnRleCIsInNlY29uZFZlcnRleCIsImVkZ2UiLCJpbmNvbWluZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJhZGRJbmNvbWluZ0VkZ2UiLCJhZGRPdXRnb2luZ0VkZ2UiLCJzdGFydGluZ1ZlcnRpY2VzIiwiZmlsdGVyIiwidmVydGV4U3RhcnRpbmciLCJpc1N0YXJ0aW5nIiwic3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCIsImxlbmd0aCIsInN0YXJ0aW5nVmVydGV4IiwicG9wIiwic29ydGVkVmVydGV4IiwiYmFja3dhcmRzRm9yRWFjaCIsImluZGV4IiwiZ2V0Rmlyc3RWZXJ0ZXgiLCJlZGdlU3RhcnRpbmciLCJzcGxpY2UiLCJsYXN0VmVydGV4IiwiZ2V0TGFzdFZlcnRleCIsInJlbW92ZUluY29taW5nRWRnZSIsImxhc3RWZXJ0ZXhTdGFydGluZyIsImVkZ2VzTGVuZ3RoIiwiZm9yRWFjaE91dGdvaW5nRWRnZSIsIm91dGdvaW5nRWRnZUxhc3RWZXJ0ZXgiLCJhbmNlc3RvclZlcnRleCIsImFuY2VzdG9yVmVydGljZXMiLCJnZXRBbmNlc3RvclZlcnRpY2VzIiwiYWRkQW5jZXN0b3JWZXJ0aWNlcyIsImFkZEFuY2VzdG9yVmVydGV4Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUEsSUFBTUEsT0FBT0MsUUFBUSxjQUFSLENBQWI7QUFBQSxJQUNNQyxTQUFTRCxRQUFRLGdCQUFSLENBRGY7QUFBQSxJQUVNRSxZQUFZRixRQUFRLGNBQVIsQ0FGbEI7O0lBSU1HLEs7QUFDSixpQkFBYUMsY0FBYixFQUE2QjtBQUFBOztBQUMzQixTQUFLQSxjQUFMLEdBQXNCQSxjQUF0QjtBQUNEOzs7O3dDQUVtQjtBQUNsQixhQUFPLEtBQUtBLGNBQVo7QUFDRDs7O3VDQUV5QkMsYyxFQUFnQjtBQUN4QyxVQUFNQyxXQUFXLEVBQWpCO0FBQUEsVUFDTUMsUUFBUSxFQURkOztBQUdBQyx5Q0FBbUNILGNBQW5DLEVBQW1EQyxRQUFuRCxFQUE2REMsS0FBN0Q7O0FBRUEsVUFBTUgsaUJBQWlCSyxtQ0FBbUNILFFBQW5DLEVBQTZDQyxLQUE3QyxDQUF2Qjs7QUFFQUcsMENBQW9DTixjQUFwQzs7QUFFQSxVQUFNTyxRQUFRLElBQUlSLEtBQUosQ0FBVUMsY0FBVixDQUFkOztBQUVBLGFBQU9PLEtBQVA7QUFDRDs7Ozs7O0FBR0hDLE9BQU9DLE9BQVAsR0FBaUJWLEtBQWpCOztBQUVBLFNBQVNLLGtDQUFULENBQTRDSCxjQUE1QyxFQUE0REMsUUFBNUQsRUFBc0VDLEtBQXRFLEVBQTZFO0FBQzNFLE1BQU1PLFlBQVksRUFBbEI7O0FBRUFULGlCQUFlVSxPQUFmLENBQXVCLFVBQVNDLGFBQVQsRUFBd0I7QUFDN0MsUUFBTUMsNEJBQTRCZixVQUFVZ0IsS0FBVixDQUFnQkYsYUFBaEIsQ0FBbEM7QUFB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QVczRCxTQUFPRCx5QkFBeUIsQ0FBaEMsRUFBbUM7QUFBQTtBQTJCbEM7O0FBRUQsTUFBTWMsY0FBY2pELE1BQU1vQyxNQUExQjs7QUFFQSxNQUFJYSxjQUFjLENBQWxCLEVBQXFCO0FBQ25CcEQscUJBQWlCLElBQWpCO0FBQ0Q7O0FBRUQsU0FBT0EsY0FBUDtBQUNEOztBQUVELFNBQVNNLG1DQUFULENBQTZDTixjQUE3QyxFQUE2RDtBQUMzRCxNQUFJQSxtQkFBbUIsSUFBdkIsRUFBNkI7QUFDM0JBLG1CQUFlVyxPQUFmLENBQXVCLFVBQVMrQixZQUFULEVBQXVCO0FBQzVDQSxtQkFBYVcsbUJBQWIsQ0FBaUMsVUFBU3RCLFlBQVQsRUFBdUI7QUFDdEQsWUFBTXVCLHlCQUF5QnZCLGFBQWFrQixhQUFiLEVBQS9CO0FBQUEsWUFDTXhCLG1CQUFtQjZCLHNCQUR6QjtBQUFBLFlBQ2tEO0FBQzVDQyx5QkFBaUJiLFlBRnZCO0FBQUEsWUFFc0M7QUFDaENjLDJCQUFtQkQsZUFBZUUsbUJBQWYsRUFIekIsQ0FEc0QsQ0FJVTs7QUFFaEVoQyx5QkFBaUJpQyxtQkFBakIsQ0FBcUNGLGdCQUFyQzs7QUFFQS9CLHlCQUFpQmtDLGlCQUFqQixDQUFtQ0osY0FBbkM7QUFDRCxPQVREO0FBVUQsS0FYRDtBQVlEO0FBQ0YiLCJmaWxlIjoiZ3JhcGguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVkZ2UgPSByZXF1aXJlKCcuL2dyYXBoL2VkZ2UnKSxcbiAgICAgIFZlcnRleCA9IHJlcXVpcmUoJy4vZ3JhcGgvdmVydGV4JyksXG4gICAgICBhcnJheVV0aWwgPSByZXF1aXJlKCcuL3V0aWwvYXJyYXknKTtcblxuY2xhc3MgR3JhcGgge1xuICBjb25zdHJ1Y3RvciAoc29ydGVkVmVydGljZXMpIHtcbiAgICB0aGlzLnNvcnRlZFZlcnRpY2VzID0gc29ydGVkVmVydGljZXM7XG4gIH1cblxuICBnZXRTb3J0ZWRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zb3J0ZWRWZXJ0aWNlcztcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICAgIGVkZ2VzID0gW107XG5cbiAgICB2ZXJ0aWNlc0FuZEVkZ2VzRnJvbVZlcnRleExpdGVyYWxzKHZlcnRleExpdGVyYWxzLCB2ZXJ0aWNlcywgZWRnZXMpO1xuXG4gICAgY29uc3Qgc29ydGVkVmVydGljZXMgPSBzb3J0ZWRWZXJ0aWNlc0Zyb21WZXJ0aWNlc0FuZEVkZ2VzKHZlcnRpY2VzLCBlZGdlcyk7XG4gICAgXG4gICAgYWRkQW5jZXN0b3JWZXJ0aWNlc1RvU29ydGVkVmVydGljZXMoc29ydGVkVmVydGljZXMpO1xuICAgIFxuICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKHNvcnRlZFZlcnRpY2VzKTtcbiAgICBcbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxuZnVuY3Rpb24gdmVydGljZXNBbmRFZGdlc0Zyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscywgdmVydGljZXMsIGVkZ2VzKSB7XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGRlc2NlbmRhbnRWZXJ0ZXhOYW1lcyA9IHNlY29uZFZlcnRleExpdGVyYWxFbGVtZW50LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhOYW1lID0gZmlyc3RWZXJ0ZXhMaXRlcmFsRWxlbWVudDsgLy8vXG5cbiAgICBsZXQgdmVydGV4O1xuXG4gICAgY29uc3QgdmVydGV4RXhpc3RzID0gdmVydGV4TWFwLmhhc093blByb3BlcnR5KHZlcnRleE5hbWUpO1xuXG4gICAgaWYgKHZlcnRleEV4aXN0cykge1xuICAgICAgdmVydGV4ID0gdmVydGV4TWFwW3ZlcnRleE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJ0ZXggPSBWZXJ0ZXguZnJvbVZlcnRleE5hbWUodmVydGV4TmFtZSk7XG5cbiAgICAgIHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXSA9IHZlcnRleDtcblxuICAgICAgdmVydGljZXMucHVzaCh2ZXJ0ZXgpO1xuICAgIH1cblxuICAgIGRlc2NlbmRhbnRWZXJ0ZXhOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGRlc2NlbmRhbnRWZXJ0ZXhOYW1lKSB7XG4gICAgICBsZXQgZGVzY2VuZGFudFZlcnRleDtcblxuICAgICAgY29uc3QgZGVzY2VuZGFudFZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eShkZXNjZW5kYW50VmVydGV4TmFtZSk7XG5cbiAgICAgIGlmIChkZXNjZW5kYW50VmVydGV4RXhpc3RzKSB7XG4gICAgICAgIGRlc2NlbmRhbnRWZXJ0ZXggPSB2ZXJ0ZXhNYXBbZGVzY2VuZGFudFZlcnRleE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzY2VuZGFudFZlcnRleCA9IFZlcnRleC5mcm9tVmVydGV4TmFtZShkZXNjZW5kYW50VmVydGV4TmFtZSk7XG5cbiAgICAgICAgdmVydGV4TWFwW2Rlc2NlbmRhbnRWZXJ0ZXhOYW1lXSA9IGRlc2NlbmRhbnRWZXJ0ZXg7XG5cbiAgICAgICAgdmVydGljZXMucHVzaChkZXNjZW5kYW50VmVydGV4KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlyc3RWZXJ0ZXggPSB2ZXJ0ZXgsXG4gICAgICAgICAgICBzZWNvbmRWZXJ0ZXggPSBkZXNjZW5kYW50VmVydGV4LFxuICAgICAgICAgICAgZWRnZSA9IG5ldyBFZGdlKGZpcnN0VmVydGV4LCBzZWNvbmRWZXJ0ZXgpO1xuXG4gICAgICBlZGdlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICBjb25zdCBpbmNvbWluZ0VkZ2UgPSBlZGdlLCAgLy8vXG4gICAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgIGRlc2NlbmRhbnRWZXJ0ZXguYWRkSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG5cbiAgICAgIHZlcnRleC5hZGRPdXRnb2luZ0VkZ2Uob3V0Z29pbmdFZGdlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZFZlcnRpY2VzRnJvbVZlcnRpY2VzQW5kRWRnZXModmVydGljZXMsIGVkZ2VzKSB7XG4gIGxldCBzb3J0ZWRWZXJ0aWNlcyA9IFtdO1xuICBcbiAgY29uc3Qgc3RhcnRpbmdWZXJ0aWNlcyA9IHZlcnRpY2VzLmZpbHRlcihmdW5jdGlvbih2ZXJ0ZXgpIHtcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXhTdGFydGluZyA9IHZlcnRleC5pc1N0YXJ0aW5nKCk7XG4gICAgICBcbiAgICAgICAgICByZXR1cm4gdmVydGV4U3RhcnRpbmc7XG4gICAgICAgIH0pO1xuXG4gIGxldCBzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID0gc3RhcnRpbmdWZXJ0aWNlcy5sZW5ndGg7XG5cbiAgd2hpbGUgKHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc3RhcnRpbmdWZXJ0ZXggPSBzdGFydGluZ1ZlcnRpY2VzLnBvcCgpLFxuICAgICAgICAgIHNvcnRlZFZlcnRleCA9IHN0YXJ0aW5nVmVydGV4OyAgLy8vXG5cbiAgICBzb3J0ZWRWZXJ0aWNlcy5wdXNoKHNvcnRlZFZlcnRleCk7XG5cbiAgICBhcnJheVV0aWwuYmFja3dhcmRzRm9yRWFjaChlZGdlcywgZnVuY3Rpb24oZWRnZSwgaW5kZXgpIHtcbiAgICAgIGNvbnN0IGZpcnN0VmVydGV4ID0gZWRnZS5nZXRGaXJzdFZlcnRleCgpLFxuICAgICAgICAgICAgZWRnZVN0YXJ0aW5nID0gKGZpcnN0VmVydGV4ID09PSBzdGFydGluZ1ZlcnRleCk7XG5cbiAgICAgIGlmIChlZGdlU3RhcnRpbmcpIHtcbiAgICAgICAgZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICBjb25zdCBsYXN0VmVydGV4ID0gZWRnZS5nZXRMYXN0VmVydGV4KCksXG4gICAgICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgICAgICBsYXN0VmVydGV4LnJlbW92ZUluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuXG4gICAgICAgIGNvbnN0IGxhc3RWZXJ0ZXhTdGFydGluZyA9IGxhc3RWZXJ0ZXguaXNTdGFydGluZygpO1xuXG4gICAgICAgIGlmIChsYXN0VmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICBzdGFydGluZ1ZlcnRpY2VzLnB1c2gobGFzdFZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHN0YXJ0aW5nVmVydGljZXNMZW5ndGggPSBzdGFydGluZ1ZlcnRpY2VzLmxlbmd0aDtcbiAgfVxuXG4gIGNvbnN0IGVkZ2VzTGVuZ3RoID0gZWRnZXMubGVuZ3RoO1xuXG4gIGlmIChlZGdlc0xlbmd0aCA+IDApIHtcbiAgICBzb3J0ZWRWZXJ0aWNlcyA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gc29ydGVkVmVydGljZXM7XG59XG5cbmZ1bmN0aW9uIGFkZEFuY2VzdG9yVmVydGljZXNUb1NvcnRlZFZlcnRpY2VzKHNvcnRlZFZlcnRpY2VzKSB7XG4gIGlmIChzb3J0ZWRWZXJ0aWNlcyAhPT0gbnVsbCkge1xuICAgIHNvcnRlZFZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24oc29ydGVkVmVydGV4KSB7XG4gICAgICBzb3J0ZWRWZXJ0ZXguZm9yRWFjaE91dGdvaW5nRWRnZShmdW5jdGlvbihvdXRnb2luZ0VkZ2UpIHtcbiAgICAgICAgY29uc3Qgb3V0Z29pbmdFZGdlTGFzdFZlcnRleCA9IG91dGdvaW5nRWRnZS5nZXRMYXN0VmVydGV4KCksXG4gICAgICAgICAgICAgIGRlc2NlbmRhbnRWZXJ0ZXggPSBvdXRnb2luZ0VkZ2VMYXN0VmVydGV4LCAgLy8vXG4gICAgICAgICAgICAgIGFuY2VzdG9yVmVydGV4ID0gc29ydGVkVmVydGV4LCAgLy8vXG4gICAgICAgICAgICAgIGFuY2VzdG9yVmVydGljZXMgPSBhbmNlc3RvclZlcnRleC5nZXRBbmNlc3RvclZlcnRpY2VzKCk7ICAvLy9cblxuICAgICAgICBkZXNjZW5kYW50VmVydGV4LmFkZEFuY2VzdG9yVmVydGljZXMoYW5jZXN0b3JWZXJ0aWNlcyk7XG5cbiAgICAgICAgZGVzY2VuZGFudFZlcnRleC5hZGRBbmNlc3RvclZlcnRleChhbmNlc3RvclZlcnRleCk7XG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59XG4iXX0=