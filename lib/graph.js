'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Edge = require('./graph/edge'),
    Vertex = require('./graph/vertex'),
    arrayUtil = require('./util/array');

var Graph = function () {
  function Graph(topologicallyOrderedVertices, remainingEdges) {
    _classCallCheck(this, Graph);

    this.topologicallyOrderedVertices = topologicallyOrderedVertices;
    this.remainingEdges = remainingEdges;
  }

  _createClass(Graph, [{
    key: 'getTopologicallyOrderedVertices',
    value: function getTopologicallyOrderedVertices() {
      return this.topologicallyOrderedVertices;
    }
  }, {
    key: 'getRemainingEdges',
    value: function getRemainingEdges() {
      return this.remainingEdges;
    }
  }, {
    key: 'areCyclesPresent',
    value: function areCyclesPresent() {
      var remainingEdgesLength = this.remainingEdges.length,
          cyclesPresent = remainingEdgesLength !== 0;

      return cyclesPresent;
    }
  }, {
    key: 'forEachRemainingEdgeVertexNames',
    value: function forEachRemainingEdgeVertexNames(callback) {
      this.remainingEdges.forEach(function (remainingEdge) {
        var remainingEdgeSourceVertex = remainingEdge.getSourceVertex(),
            remainingEdgeTargetVertex = remainingEdge.getTargetVertex(),
            remainingEdgeSourceVertexName = remainingEdgeSourceVertex.getName(),
            remainingEdgeTargetVertexName = remainingEdgeTargetVertex.getName();

        callback(remainingEdgeSourceVertexName, remainingEdgeTargetVertexName);
      });
    }
  }], [{
    key: 'fromVertexLiterals',
    value: function fromVertexLiterals(vertexLiterals) {
      var vertexMap = vertexMapFromVertexLiterals(vertexLiterals),
          edges = edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap),
          topologicallyOrderedVertices = topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges),
          remainingEdges = edges,
          ///
      graph = new Graph(topologicallyOrderedVertices, remainingEdges);

      return graph;
    }
  }]);

  return Graph;
}();

module.exports = Graph;

function vertexMapFromVertexLiterals(vertexLiterals) {
  var vertexMap = {};

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        vertexName = firstVertexLiteralElement,
        ///
    vertexExists = vertexMap.hasOwnProperty(vertexName);

    if (!vertexExists) {
      var vertex = Vertex.fromVertexName(vertexName);

      vertexMap[vertexName] = vertex;
    }

    var secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement; ///

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertexExists = vertexMap.hasOwnProperty(ancestorVertexName);

      if (!ancestorVertexExists) {
        var ancestorVertex = Vertex.fromVertexName(ancestorVertexName);

        vertexMap[ancestorVertexName] = ancestorVertex;
      }
    });
  });

  return vertexMap;
}

function edgesFromVertexLiteralsAndVertexMap(vertexLiterals, vertexMap) {
  var edges = [];

  vertexLiterals.forEach(function (vertexLiteral) {
    var firstVertexLiteralElement = arrayUtil.first(vertexLiteral),
        secondVertexLiteralElement = arrayUtil.second(vertexLiteral),
        ancestorVertexNames = secondVertexLiteralElement,
        ///
    vertexName = firstVertexLiteralElement,
        ///
    vertex = vertexMap[vertexName];

    ancestorVertexNames.forEach(function (ancestorVertexName) {
      var ancestorVertex = vertexMap[ancestorVertexName],
          sourceVertex = ancestorVertex,
          ///
      targetVertex = vertex,
          ///
      edge = new Edge(sourceVertex, targetVertex),
          incomingEdge = edge,
          ///
      outgoingEdge = edge; ///

      edges.push(edge);

      sourceVertex.addOutgoingEdge(outgoingEdge);

      targetVertex.addIncomingEdge(incomingEdge);
    });
  });

  return edges;
}

function topologicallyOrderedVerticesFromVertexMapAndEdges(vertexMap, edges) {
  var topologicallyOrderedVertices = [];

  var startingVertices = startingVerticesFromVertexMap(vertexMap),
      removedEdges = [];

  var startingVerticesLength = startingVertices.length;

  var _loop = function _loop() {
    var startingVertex = startingVertices.pop(),
        topologicallyOrderedVertex = startingVertex; ///

    topologicallyOrderedVertices.push(topologicallyOrderedVertex);

    arrayUtil.backwardsForEach(edges, function (edge, index) {
      var sourceVertex = edge.getSourceVertex(),
          edgeStarting = sourceVertex === startingVertex; ///

      if (edgeStarting) {
        edges.splice(index, 1);

        var targetVertex = edge.getTargetVertex(),
            incomingEdge = edge,
            ///
        removedEdge = edge; ///

        targetVertex.removeIncomingEdge(incomingEdge);

        removedEdges.push(removedEdge);

        var targetVertexStarting = targetVertex.isStarting();

        if (targetVertexStarting) {
          var _startingVertex = targetVertex; ///

          startingVertices.push(_startingVertex);
        }
      }
    });

    startingVerticesLength = startingVertices.length;
  };

  while (startingVerticesLength > 0) {
    _loop();
  }

  var edgesLength = edges.length;

  if (edgesLength === 0) {
    removedEdges.forEach(function (removedEdge) {
      var targetVertex = removedEdge.getTargetVertex(),
          incomingEdge = removedEdge; ///

      targetVertex.addIncomingEdge(incomingEdge);
    });
  }

  return topologicallyOrderedVertices;
}

function startingVerticesFromVertexMap(vertexMap) {
  var vertexNames = Object.keys(vertexMap),
      startingVertices = vertexNames.reduce(function (startingVertices, vertexName) {
    var vertex = vertexMap[vertexName],
        vertexStarting = vertex.isStarting();

    if (vertexStarting) {
      var _startingVertex2 = vertex; ///

      startingVertices.push(_startingVertex2);
    }

    return startingVertices;
  }, []);

  return startingVertices;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2VzNi9ncmFwaC5qcyJdLCJuYW1lcyI6WyJFZGdlIiwicmVxdWlyZSIsIlZlcnRleCIsImFycmF5VXRpbCIsIkdyYXBoIiwidG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyIsInJlbWFpbmluZ0VkZ2VzIiwicmVtYWluaW5nRWRnZXNMZW5ndGgiLCJsZW5ndGgiLCJjeWNsZXNQcmVzZW50IiwiY2FsbGJhY2siLCJmb3JFYWNoIiwicmVtYWluaW5nRWRnZSIsInJlbWFpbmluZ0VkZ2VTb3VyY2VWZXJ0ZXgiLCJnZXRTb3VyY2VWZXJ0ZXgiLCJyZW1haW5pbmdFZGdlVGFyZ2V0VmVydGV4IiwiZ2V0VGFyZ2V0VmVydGV4IiwicmVtYWluaW5nRWRnZVNvdXJjZVZlcnRleE5hbWUiLCJnZXROYW1lIiwicmVtYWluaW5nRWRnZVRhcmdldFZlcnRleE5hbWUiLCJ2ZXJ0ZXhMaXRlcmFscyIsInZlcnRleE1hcCIsInZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyIsImVkZ2VzIiwiZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAiLCJ0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzRnJvbVZlcnRleE1hcEFuZEVkZ2VzIiwiZ3JhcGgiLCJtb2R1bGUiLCJleHBvcnRzIiwidmVydGV4TGl0ZXJhbCIsImZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJmaXJzdCIsInZlcnRleE5hbWUiLCJ2ZXJ0ZXhFeGlzdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInZlcnRleCIsImZyb21WZXJ0ZXhOYW1lIiwic2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQiLCJzZWNvbmQiLCJhbmNlc3RvclZlcnRleE5hbWVzIiwiYW5jZXN0b3JWZXJ0ZXhOYW1lIiwiYW5jZXN0b3JWZXJ0ZXhFeGlzdHMiLCJhbmNlc3RvclZlcnRleCIsInNvdXJjZVZlcnRleCIsInRhcmdldFZlcnRleCIsImVkZ2UiLCJpbmNvbWluZ0VkZ2UiLCJvdXRnb2luZ0VkZ2UiLCJwdXNoIiwiYWRkT3V0Z29pbmdFZGdlIiwiYWRkSW5jb21pbmdFZGdlIiwic3RhcnRpbmdWZXJ0aWNlcyIsInN0YXJ0aW5nVmVydGljZXNGcm9tVmVydGV4TWFwIiwicmVtb3ZlZEVkZ2VzIiwic3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCIsInN0YXJ0aW5nVmVydGV4IiwicG9wIiwidG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXgiLCJiYWNrd2FyZHNGb3JFYWNoIiwiaW5kZXgiLCJlZGdlU3RhcnRpbmciLCJzcGxpY2UiLCJyZW1vdmVkRWRnZSIsInJlbW92ZUluY29taW5nRWRnZSIsInRhcmdldFZlcnRleFN0YXJ0aW5nIiwiaXNTdGFydGluZyIsImVkZ2VzTGVuZ3RoIiwidmVydGV4TmFtZXMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwidmVydGV4U3RhcnRpbmciXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQSxJQUFNQSxPQUFPQyxRQUFRLGNBQVIsQ0FBYjtBQUFBLElBQ01DLFNBQVNELFFBQVEsZ0JBQVIsQ0FEZjtBQUFBLElBRU1FLFlBQVlGLFFBQVEsY0FBUixDQUZsQjs7SUFJTUcsSztBQUNKLGlCQUFhQyw0QkFBYixFQUEyQ0MsY0FBM0MsRUFBMkQ7QUFBQTs7QUFDekQsU0FBS0QsNEJBQUwsR0FBb0NBLDRCQUFwQztBQUNBLFNBQUtDLGNBQUwsR0FBc0JBLGNBQXRCO0FBQ0Q7Ozs7c0RBRWlDO0FBQ2hDLGFBQU8sS0FBS0QsNEJBQVo7QUFDRDs7O3dDQUVtQjtBQUNsQixhQUFPLEtBQUtDLGNBQVo7QUFDRDs7O3VDQUVrQjtBQUNqQixVQUFNQyx1QkFBdUIsS0FBS0QsY0FBTCxDQUFvQkUsTUFBakQ7QUFBQSxVQUNNQyxnQkFBaUJGLHlCQUF5QixDQURoRDs7QUFHQSxhQUFPRSxhQUFQO0FBQ0Q7OztvREFFK0JDLFEsRUFBVTtBQUN4QyxXQUFLSixjQUFMLENBQW9CSyxPQUFwQixDQUE0QixVQUFTQyxhQUFULEVBQXdCO0FBQ2xELFlBQU1DLDRCQUE0QkQsY0FBY0UsZUFBZCxFQUFsQztBQUFB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LDJCQUFpQkgsSUFBakIsQ0FBc0JPLGVBQXRCO0FBQ0Q7QUFDRjtBQUNGLEtBdkJEOztBQXlCQUQsNkJBQXlCSCxpQkFBaUIzQyxNQUExQztBQXZDeUU7O0FBUTNFLFNBQU84Qyx5QkFBeUIsQ0FBaEMsRUFBbUM7QUFBQTtBQWdDbEM7O0FBRUQsTUFBTVksY0FBYzNDLE1BQU1mLE1BQTFCOztBQUVBLE1BQUkwRCxnQkFBZ0IsQ0FBcEIsRUFBdUI7QUFDckJiLGlCQUFhMUMsT0FBYixDQUFxQixVQUFTbUQsV0FBVCxFQUFzQjtBQUN6QyxVQUFNbEIsZUFBZWtCLFlBQVk5QyxlQUFaLEVBQXJCO0FBQUEsVUFDTThCLGVBQWVnQixXQURyQixDQUR5QyxDQUVQOztBQUVsQ2xCLG1CQUFhTSxlQUFiLENBQTZCSixZQUE3QjtBQUNELEtBTEQ7QUFNRDs7QUFFRCxTQUFPekMsNEJBQVA7QUFDRDs7QUFFRCxTQUFTK0MsNkJBQVQsQ0FBdUMvQixTQUF2QyxFQUFrRDtBQUNoRCxNQUFNOEMsY0FBY0MsT0FBT0MsSUFBUCxDQUFZaEQsU0FBWixDQUFwQjtBQUFBLE1BQ004QixtQkFBbUJnQixZQUFZRyxNQUFaLENBQW1CLFVBQVNuQixnQkFBVCxFQUEyQm5CLFVBQTNCLEVBQXVDO0FBQzNFLFFBQU1HLFNBQVNkLFVBQVVXLFVBQVYsQ0FBZjtBQUFBLFFBQ011QyxpQkFBaUJwQyxPQUFPOEIsVUFBUCxFQUR2Qjs7QUFHQSxRQUFJTSxjQUFKLEVBQW9CO0FBQ2xCLFVBQU1oQixtQkFBaUJwQixNQUF2QixDQURrQixDQUNjOztBQUVoQ2dCLHVCQUFpQkgsSUFBakIsQ0FBc0JPLGdCQUF0QjtBQUNEOztBQUVELFdBQU9KLGdCQUFQO0FBQ0QsR0FYa0IsRUFXaEIsRUFYZ0IsQ0FEekI7O0FBY0EsU0FBT0EsZ0JBQVA7QUFDRCIsImZpbGUiOiJncmFwaC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRWRnZSA9IHJlcXVpcmUoJy4vZ3JhcGgvZWRnZScpLFxuICAgICAgVmVydGV4ID0gcmVxdWlyZSgnLi9ncmFwaC92ZXJ0ZXgnKSxcbiAgICAgIGFycmF5VXRpbCA9IHJlcXVpcmUoJy4vdXRpbC9hcnJheScpO1xuXG5jbGFzcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yICh0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLCByZW1haW5pbmdFZGdlcykge1xuICAgIHRoaXMudG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXM7XG4gICAgdGhpcy5yZW1haW5pbmdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzO1xuICB9XG5cbiAgZ2V0VG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy50b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzO1xuICB9XG5cbiAgZ2V0UmVtYWluaW5nRWRnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtYWluaW5nRWRnZXM7XG4gIH1cblxuICBhcmVDeWNsZXNQcmVzZW50KCkge1xuICAgIGNvbnN0IHJlbWFpbmluZ0VkZ2VzTGVuZ3RoID0gdGhpcy5yZW1haW5pbmdFZGdlcy5sZW5ndGgsXG4gICAgICAgICAgY3ljbGVzUHJlc2VudCA9IChyZW1haW5pbmdFZGdlc0xlbmd0aCAhPT0gMCk7XG4gICAgXG4gICAgcmV0dXJuIGN5Y2xlc1ByZXNlbnQ7XG4gIH1cblxuICBmb3JFYWNoUmVtYWluaW5nRWRnZVZlcnRleE5hbWVzKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZW1haW5pbmdFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlbWFpbmluZ0VkZ2UpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0VkZ2VTb3VyY2VWZXJ0ZXggPSByZW1haW5pbmdFZGdlLmdldFNvdXJjZVZlcnRleCgpLFxuICAgICAgICAgICAgcmVtYWluaW5nRWRnZVRhcmdldFZlcnRleCA9IHJlbWFpbmluZ0VkZ2UuZ2V0VGFyZ2V0VmVydGV4KCksXG4gICAgICAgICAgICByZW1haW5pbmdFZGdlU291cmNlVmVydGV4TmFtZSA9IHJlbWFpbmluZ0VkZ2VTb3VyY2VWZXJ0ZXguZ2V0TmFtZSgpLFxuICAgICAgICAgICAgcmVtYWluaW5nRWRnZVRhcmdldFZlcnRleE5hbWUgPSByZW1haW5pbmdFZGdlVGFyZ2V0VmVydGV4LmdldE5hbWUoKTtcbiAgICAgIFxuICAgICAgY2FsbGJhY2socmVtYWluaW5nRWRnZVNvdXJjZVZlcnRleE5hbWUsIHJlbWFpbmluZ0VkZ2VUYXJnZXRWZXJ0ZXhOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpIHtcbiAgICBjb25zdCB2ZXJ0ZXhNYXAgPSB2ZXJ0ZXhNYXBGcm9tVmVydGV4TGl0ZXJhbHModmVydGV4TGl0ZXJhbHMpLFxuICAgICAgICAgIGVkZ2VzID0gZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAodmVydGV4TGl0ZXJhbHMsIHZlcnRleE1hcCksXG4gICAgICAgICAgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyA9IHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcyksXG4gICAgICAgICAgcmVtYWluaW5nRWRnZXMgPSBlZGdlcywgLy8vXG4gICAgICAgICAgZ3JhcGggPSBuZXcgR3JhcGgodG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcywgcmVtYWluaW5nRWRnZXMpO1xuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG5cbmZ1bmN0aW9uIHZlcnRleE1hcEZyb21WZXJ0ZXhMaXRlcmFscyh2ZXJ0ZXhMaXRlcmFscykge1xuICBjb25zdCB2ZXJ0ZXhNYXAgPSB7fTtcblxuICB2ZXJ0ZXhMaXRlcmFscy5mb3JFYWNoKGZ1bmN0aW9uKHZlcnRleExpdGVyYWwpIHtcbiAgICBjb25zdCBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50ID0gYXJyYXlVdGlsLmZpcnN0KHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIHZlcnRleE5hbWUgPSBmaXJzdFZlcnRleExpdGVyYWxFbGVtZW50LCAvLy9cbiAgICAgICAgICB2ZXJ0ZXhFeGlzdHMgPSB2ZXJ0ZXhNYXAuaGFzT3duUHJvcGVydHkodmVydGV4TmFtZSk7XG5cbiAgICBpZiAoIXZlcnRleEV4aXN0cykge1xuICAgICAgY29uc3QgdmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKHZlcnRleE5hbWUpO1xuXG4gICAgICB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0gPSB2ZXJ0ZXg7XG4gICAgfVxuXG4gICAgY29uc3Qgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGFuY2VzdG9yVmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudDsgLy8vXG5cbiAgICBhbmNlc3RvclZlcnRleE5hbWVzLmZvckVhY2goZnVuY3Rpb24oYW5jZXN0b3JWZXJ0ZXhOYW1lKSB7XG4gICAgICBjb25zdCBhbmNlc3RvclZlcnRleEV4aXN0cyA9IHZlcnRleE1hcC5oYXNPd25Qcm9wZXJ0eShhbmNlc3RvclZlcnRleE5hbWUpO1xuXG4gICAgICBpZiAoIWFuY2VzdG9yVmVydGV4RXhpc3RzKSB7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4ID0gVmVydGV4LmZyb21WZXJ0ZXhOYW1lKGFuY2VzdG9yVmVydGV4TmFtZSk7XG5cbiAgICAgICAgdmVydGV4TWFwW2FuY2VzdG9yVmVydGV4TmFtZV0gPSBhbmNlc3RvclZlcnRleDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHZlcnRleE1hcDtcbn1cblxuZnVuY3Rpb24gZWRnZXNGcm9tVmVydGV4TGl0ZXJhbHNBbmRWZXJ0ZXhNYXAodmVydGV4TGl0ZXJhbHMsIHZlcnRleE1hcCkge1xuICBjb25zdCBlZGdlcyA9IFtdO1xuXG4gIHZlcnRleExpdGVyYWxzLmZvckVhY2goZnVuY3Rpb24odmVydGV4TGl0ZXJhbCkge1xuICAgIGNvbnN0IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuZmlyc3QodmVydGV4TGl0ZXJhbCksXG4gICAgICAgICAgc2Vjb25kVmVydGV4TGl0ZXJhbEVsZW1lbnQgPSBhcnJheVV0aWwuc2Vjb25kKHZlcnRleExpdGVyYWwpLFxuICAgICAgICAgIGFuY2VzdG9yVmVydGV4TmFtZXMgPSBzZWNvbmRWZXJ0ZXhMaXRlcmFsRWxlbWVudCwgLy8vXG4gICAgICAgICAgdmVydGV4TmFtZSA9IGZpcnN0VmVydGV4TGl0ZXJhbEVsZW1lbnQsIC8vL1xuICAgICAgICAgIHZlcnRleCA9IHZlcnRleE1hcFt2ZXJ0ZXhOYW1lXTtcblxuICAgIGFuY2VzdG9yVmVydGV4TmFtZXMuZm9yRWFjaChmdW5jdGlvbihhbmNlc3RvclZlcnRleE5hbWUpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yVmVydGV4ID0gdmVydGV4TWFwW2FuY2VzdG9yVmVydGV4TmFtZV0sXG4gICAgICAgICAgICBzb3VyY2VWZXJ0ZXggPSBhbmNlc3RvclZlcnRleCwgLy8vXG4gICAgICAgICAgICB0YXJnZXRWZXJ0ZXggPSB2ZXJ0ZXgsICAvLy9cbiAgICAgICAgICAgIGVkZ2UgPSBuZXcgRWRnZShzb3VyY2VWZXJ0ZXgsIHRhcmdldFZlcnRleCksXG4gICAgICAgICAgICBpbmNvbWluZ0VkZ2UgPSBlZGdlLCAgLy8vXG4gICAgICAgICAgICBvdXRnb2luZ0VkZ2UgPSBlZGdlOyAgLy8vXG5cbiAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG5cbiAgICAgIHNvdXJjZVZlcnRleC5hZGRPdXRnb2luZ0VkZ2Uob3V0Z29pbmdFZGdlKTtcblxuICAgICAgdGFyZ2V0VmVydGV4LmFkZEluY29taW5nRWRnZShpbmNvbWluZ0VkZ2UpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbmZ1bmN0aW9uIHRvcG9sb2dpY2FsbHlPcmRlcmVkVmVydGljZXNGcm9tVmVydGV4TWFwQW5kRWRnZXModmVydGV4TWFwLCBlZGdlcykge1xuICBsZXQgdG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0aWNlcyA9IFtdO1xuXG4gIGNvbnN0IHN0YXJ0aW5nVmVydGljZXMgPSBzdGFydGluZ1ZlcnRpY2VzRnJvbVZlcnRleE1hcCh2ZXJ0ZXhNYXApLFxuICAgICAgICByZW1vdmVkRWRnZXMgPSBbXTtcblxuICBsZXQgc3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCA9IHN0YXJ0aW5nVmVydGljZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydGluZ1ZlcnRpY2VzTGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHN0YXJ0aW5nVmVydGV4ID0gc3RhcnRpbmdWZXJ0aWNlcy5wb3AoKSxcbiAgICAgICAgICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRleCA9IHN0YXJ0aW5nVmVydGV4OyAgLy8vXG5cbiAgICB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzLnB1c2godG9wb2xvZ2ljYWxseU9yZGVyZWRWZXJ0ZXgpO1xuXG4gICAgYXJyYXlVdGlsLmJhY2t3YXJkc0ZvckVhY2goZWRnZXMsIGZ1bmN0aW9uKGVkZ2UsIGluZGV4KSB7XG4gICAgICBjb25zdCBzb3VyY2VWZXJ0ZXggPSBlZGdlLmdldFNvdXJjZVZlcnRleCgpLFxuICAgICAgICAgICAgZWRnZVN0YXJ0aW5nID0gKHNvdXJjZVZlcnRleCA9PT0gc3RhcnRpbmdWZXJ0ZXgpOyAvLy9cblxuICAgICAgaWYgKGVkZ2VTdGFydGluZykge1xuICAgICAgICBlZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFZlcnRleCA9IGVkZ2UuZ2V0VGFyZ2V0VmVydGV4KCksXG4gICAgICAgICAgICAgIGluY29taW5nRWRnZSA9IGVkZ2UsIC8vL1xuICAgICAgICAgICAgICByZW1vdmVkRWRnZSA9IGVkZ2U7ICAvLy9cblxuICAgICAgICB0YXJnZXRWZXJ0ZXgucmVtb3ZlSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG5cbiAgICAgICAgcmVtb3ZlZEVkZ2VzLnB1c2gocmVtb3ZlZEVkZ2UpO1xuXG4gICAgICAgIGNvbnN0IHRhcmdldFZlcnRleFN0YXJ0aW5nID0gdGFyZ2V0VmVydGV4LmlzU3RhcnRpbmcoKTtcblxuICAgICAgICBpZiAodGFyZ2V0VmVydGV4U3RhcnRpbmcpIHtcbiAgICAgICAgICBjb25zdCBzdGFydGluZ1ZlcnRleCA9IHRhcmdldFZlcnRleDsgIC8vL1xuXG4gICAgICAgICAgc3RhcnRpbmdWZXJ0aWNlcy5wdXNoKHN0YXJ0aW5nVmVydGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhcnRpbmdWZXJ0aWNlc0xlbmd0aCA9IHN0YXJ0aW5nVmVydGljZXMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgZWRnZXNMZW5ndGggPSBlZGdlcy5sZW5ndGg7XG5cbiAgaWYgKGVkZ2VzTGVuZ3RoID09PSAwKSB7XG4gICAgcmVtb3ZlZEVkZ2VzLmZvckVhY2goZnVuY3Rpb24ocmVtb3ZlZEVkZ2UpIHtcbiAgICAgIGNvbnN0IHRhcmdldFZlcnRleCA9IHJlbW92ZWRFZGdlLmdldFRhcmdldFZlcnRleCgpLFxuICAgICAgICAgICAgaW5jb21pbmdFZGdlID0gcmVtb3ZlZEVkZ2U7IC8vL1xuICAgICAgXG4gICAgICB0YXJnZXRWZXJ0ZXguYWRkSW5jb21pbmdFZGdlKGluY29taW5nRWRnZSk7XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB0b3BvbG9naWNhbGx5T3JkZXJlZFZlcnRpY2VzO1xufVxuXG5mdW5jdGlvbiBzdGFydGluZ1ZlcnRpY2VzRnJvbVZlcnRleE1hcCh2ZXJ0ZXhNYXApIHtcbiAgY29uc3QgdmVydGV4TmFtZXMgPSBPYmplY3Qua2V5cyh2ZXJ0ZXhNYXApLFxuICAgICAgICBzdGFydGluZ1ZlcnRpY2VzID0gdmVydGV4TmFtZXMucmVkdWNlKGZ1bmN0aW9uKHN0YXJ0aW5nVmVydGljZXMsIHZlcnRleE5hbWUpIHtcbiAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB2ZXJ0ZXhNYXBbdmVydGV4TmFtZV0sXG4gICAgICAgICAgICAgICAgdmVydGV4U3RhcnRpbmcgPSB2ZXJ0ZXguaXNTdGFydGluZygpO1xuXG4gICAgICAgICAgaWYgKHZlcnRleFN0YXJ0aW5nKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ1ZlcnRleCA9IHZlcnRleDsgIC8vL1xuXG4gICAgICAgICAgICBzdGFydGluZ1ZlcnRpY2VzLnB1c2goc3RhcnRpbmdWZXJ0ZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdGFydGluZ1ZlcnRpY2VzXG4gICAgICAgIH0sIFtdKTtcblxuICByZXR1cm4gc3RhcnRpbmdWZXJ0aWNlcztcbn1cbiJdfQ==